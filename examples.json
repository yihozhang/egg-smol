{
  "antiunify": "(datatype Expr\n  (Num i64)\n  (Var String)\n  (Add Expr Expr))\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n\n;; antiunificaiton returns an expression that could unify with either\n;; of the input expressions\n;; (AU x y) can be considered a placeholder variable\n(function AU (Expr Expr) Expr)\n\n(rewrite (AU x x) x)\n(rewrite\n (AU (Add a b) (Add c d))\n (Add (AU a c) (AU b d)))\n\n(define e1 (Add (Var \"x\") (Add (Num 1) (Num 2))))\n(define e2 (Add (Num 3) (Var \"y\")))\n\n(define au12 (AU e1 e2))\n\n(run 4)\n(check (= au12 (Add (Num 3) (AU (Var \"x\") (Var \"y\")))))\n(extract au12)\n",
  "array": "; Smtlib theory of arrays\n; https://smtlib.cs.uiowa.edu/theories-ArraysEx.shtml\n; http://smtlib.cs.uiowa.edu/version1/theories/Arrays.smt\n\n(datatype Math\n  (Num i64)\n  (Var String)\n)\n\n\n(datatype Array\n  (Const i64)\n  (AVar String)\n)\n\n(function add (Math Math) Math)\n(function select (Array Math) Math)\n(function store (Array Math Math) Array)\n\n(relation neq (Math Math))\n\n(rule ((neq x y))\n      ((neq y x)))\n\n(rule ((neq x x))\n      ((panic \"query (neq x x) found something equal to itself\")))\n\n\n; injectivity rules take not equal to not equal.\n(rule  ((neq x y) (= (add x z) e))\n       ((neq (add x z) (add y z))))\n(rule  ((= (add x (Num i)) e) (!= i 0))\n       ((neq e x)))\n\n\n(rule ((= (Num a) n1) (= (Num b) n2) (!= a b))\n      ((neq n1 n2)))\n\n; select gets from store\n(rewrite (select (store mem i e) i) e)\n; select passes through wrong index\n(rule ((= (select (store mem i1 e) i2) e1) (neq i1 i2))\n      ((set (select mem i2) e1)))\n; aliasing writes destroy old value\n(rewrite (store (store mem i e1) i e2) (store mem i e2))\n; non-aliasing writes commutes\n(rule ((= (store (store mem i2 e2) i1 e1) mem1) (neq i1 i2))\n      ((set (store (store mem i1 e1) i2 e2) mem1)))\n\n; typical math rules\n(rewrite (add x y) (add y x))\n(rewrite (add (add x y) z) (add x (add y z)))\n(rewrite (add (Num x) (Num y)) (Num (+ x y)))\n\n(define r1 (Var \"r1\"))\n(define r2 (Var \"r2\"))\n(define r3 (Var \"r3\"))\n(define mem1 (AVar \"mem1\"))\n\n(neq r1 r2)\n(neq r2 r3)\n(neq r1 r3)\n(define test1 (select (store mem1 r1 (Num 42)) r1))\n(define test2 (select (store mem1 r1 (Num 42)) (add r1 (Num 17))))\n(define test3 (select (store (store mem1 (add r1 r2) (Num 1)) (add r2 r1) (Num 2)) (add r1 r3)))\n\n(run 4)\n(check (= test1 (Num 42)))\n(check (neq r1 r2))\n(check (neq r1 (add r1 (Num 17))))\n(check (= test2 (select mem1 (add r1 (Num 17)))))\n(check (= test3 (select mem1 (add r1 r3))))\n\n\n\n",
  "bdd": "; Binary Decision Diagrams are if-then-else trees/ compressed tries that hash cons their leaves\n; This is easily expressible in the facilities provided. Everything in egg-smol is automatcally shared\n; and Compression is easily expressible as a rule.\n\n; They are a notion of first class set useful for certain classes of uniformly describable sets.\n; https://en.wikipedia.org/wiki/Binary_decision_diagram\n; https://www.lri.fr/~filliatr/ftp/publis/hash-consing2.pdf Type-Safe Modular Hash-Consing - Section 3.3\n\n(datatype BDD\n    (ITE i64 BDD BDD) ; variables labelled by number\n)\n(declare True BDD)\n(declare False BDD)\n\n; compress unneeded nodes\n(rewrite (ITE n a a) a)\n\n(function and (BDD BDD) BDD)\n(rewrite (and False n) False)\n(rewrite (and n False) False)\n(rewrite (and True x) x)\n(rewrite (and x True) x)\n; We use an order where low variables are higher in tree\n; Could go the other way.\n(rewrite (and (ITE n a1 a2) (ITE m b1 b2))\n    (ITE n (and a1 (ITE m b1 b2)) (and a2 (ITE m b1 b2)))\n    :when ((< n m))\n)\n(rewrite (and (ITE n a1 a2) (ITE m b1 b2))\n    (ITE m (and (ITE n a1 a2) b1) (and (ITE n a1 a2) b2))\n    :when ((> n m))\n)\n(rewrite (and (ITE n a1 a2) (ITE n b1 b2))\n    (ITE n (and a1 b1) (and a2 b2))\n)\n\n(define b0 (ITE 0 True False))\n(define b1 (ITE 1 True False))\n(define b2 (ITE 2 True False))\n\n(define b123 (and b2 (and b0 b1)))\n(define b11 (and b1 b1))\n(define b12 (and b1 b2))\n(run 5)\n(extract b11)\n(extract b12)\n(extract b123)\n(check (= (and (ITE 1 True False) (ITE 2 True False))\n       (ITE 1 (ITE 2 True False) False))\n)\n;(check (= b123 (ITE 3 ()))\n\n(function or (BDD BDD) BDD)\n(rewrite (or True n) True)\n(rewrite (or n True) True)\n(rewrite (or False x) x)\n(rewrite (or x False) x)\n(rewrite (or (ITE n a1 a2) (ITE m b1 b2))\n    (ITE n (or a1 (ITE m b1 b2)) (or a2 (ITE m b1 b2)))\n    :when ((< n m))\n)\n(rewrite (or (ITE n a1 a2) (ITE m b1 b2))\n    (ITE m (or (ITE n a1 a2) b1) (or (ITE n a1 a2) b2))\n    :when ((> n m))\n)\n(rewrite (or (ITE n a1 a2) (ITE n b1 b2))\n    (ITE n (or a1 b1) (or a2 b2))\n)\n\n(define or121 (or b1 (or b2 b1)))\n(run 5)\n(extract or121)\n\n(function not (BDD) BDD)\n(rewrite (not True) False)\n(rewrite (not False) True)\n(rewrite (not (ITE n a1 a2)) (not (ITE n (not a1) (not a2))))\n\n(function xor (BDD BDD) BDD)\n(rewrite (xor True n) (not n))\n(rewrite (xor n True) (not n))\n(rewrite (xor False x) x)\n(rewrite (xor x False) x)\n(rewrite (xor (ITE n a1 a2) (ITE m b1 b2))\n    (ITE n (xor a1 (ITE m b1 b2)) (or a2 (ITE m b1 b2)))\n    :when ((< n m))\n)\n(rewrite (xor (ITE n a1 a2) (ITE m b1 b2))\n    (ITE m (xor (ITE n a1 a2) b1) (or (ITE n a1 a2) b2))\n    :when ((> n m))\n)\n(rewrite (xor (ITE n a1 a2) (ITE n b1 b2))\n    (ITE n (xor a1 b1) (xor a2 b2))\n)\n\n\n",
  "before-proofs": "(set-option enable_proofs 1)\n\n(datatype Math\n    (Add Math Math)\n    (Sub Math Math)\n    (Const Rational)\n    (Var String))\n\n(rewrite (Add a b) (Add (Add a b) (Const (rational 0 1))))\n\n(rewrite (Add a b) (Add b a))\n\n\n(rewrite (Add a (Add b c))\n      (Add (Add a b) c))\n\n(define two (rational 2 1))\n(define start1 (Add (Var \"x\") (Const two)))\n;; add original proofs\n\n(run 3)\n\n\n(check (!= (Var \"x\") (Const two)))\n(check (= (Add (Var \"x\") (Const two))\n          (Add (Const two) (Var \"x\"))))\n\n(let zero (Const (rational 0 1)))\n(let addx2 (Add (Var \"x\") (Const two)))\n(let addx20 (Add addx2 zero))\n(let addzerofront (Add (Add zero (Var \"x\")) (Const two)))\n\n(check (= addx2\n          addx20))\n\n(function p1 () Proof__ :cost 100000000)\n\n(rule ((= addx2 addzerofront))\n      ((union rule-proof (p1))))\n(run 1)\n\n(run proof-extract__ 10000 :until (< (ProofCost__ (p1)) 1000000))\n(extract (p1))\n",
  "birewrite": "(datatype Math (Add Math Math) (Lit i64))\n\n(birewrite (Add (Add x y) z) (Add x (Add y z)))\n\n(define a (Lit 1))\n(define b (Lit 2))\n(define c (Lit 3))\n\n(define d (Lit 4))\n(define e (Lit 5))\n(define f (Lit 6))\n\n(define ex1 (Add (Add a b) c))\n(define ex2 (Add d (Add e f)))\n\n(run 10)\n(check (= ex1 (Add a (Add b c))))\n(check (= ex2 (Add (Add d e) f)))\n",
  "bitwise": "(check (= 0 (& 10 0)))\n(check (= 8 (& 8 10)))\n(check (= 10 (| 8 10)))\n(check (= 2 (^ 8 10)))\n(check (= 8 (<< 1 3)))\n(check (= 1 (>> 8 3)))\n(check (= 2 (% 8 3)))\n(check (= 2 (/ 8 3)))\n(check (= -1 (not-i64 0)))\n\n; bitsets\n;(function bs-union (i64 i64) i64)\n;(rewrite (bs-union a b) (| a b))\n\n;(function bs-inter (i64 i64) i64)\n;(rewrite (bs-inter a b) (& a b))\n\n;(function bs-comp (i64) i64)\n;(rewrite (bs-comp a) (bvnot a))\n\n; singleton set\n;(function bs-sing (i64) i64)\n;(rewrite (bs-sing a) (1 << a))\n\n;(function bs-insert (i64 i64) i64)\n;(rewrite (bs-insert s x) (| s (1 << a))\n\n;(function bs-diff (i64 i64) i64)\n;(rewrite (bs-diff a b) (^ a (bs-inter a b))\n\n;(define bs-empty 0)\n\n;(define bs-subset (i64 i64) bool)\n;(rewrite (bs-subset x y) (is-zero (bs-diff x y)))\n\n;(define bs-is-elem (i64 i64) bool)\n;(rewrite (bs-is-elem s x) (not (is-zero (bs-inter s (sing x)))))\n",
  "calc": "(datatype G)\n(declare I G)\n(declare A G)\n(declare B G)\n(function g* (G G) G)\n(function inv (G) G)\n(birewrite (g* (g* a b) c) (g* a (g* b c))) ; assoc\n(rewrite (g* I a) a) ; idl\n(rewrite (g* a I) a) ; idr\n(rewrite (g* (inv a) a) I) ; invl\n(rewrite (g* a (inv a)) I) ; invr\n\n; A is cyclic of period 4\n(rewrite (g* A (g* A (g* A A))) I)\n\n(define A2 (g* A A))\n(define A4 (g* A2 A2))\n(define A8 (g* A4 A4))\n\n\n(calc ()\n    (g* A4 A4)\n    (g* (g* A2 A2) (g* A2 A2))\n    (g* A2 (g* A2 (g* A2 A2)))\n)\n\n; Note that (calc ((I G) (b G)) ...) will fail because names must be unused\n(calc ((a G) (b G))\n    (g* (g* b (g* (inv a) a)) (inv b))\n    (g* b (inv b))\n    I\n)\n",
  "combinators": "; Substitution in lambda-calculus via S/K/I combinators. Extremely slow, as\n; abstraction elimination does not pay attention to whether variables are free\n; in an expression before introducing 'S'.\n;\n; Provides an example of how to implement substitution by embedding in a\n; 'richer' data-type and then mapping back to syntax.\n\n(datatype Expr\n    (Var String :cost 100)\n    (Abs String Expr)\n    (If Expr Expr Expr)\n    (N i64)\n    (Add Expr Expr)\n    (App Expr Expr))\n(declare T Expr)\n(declare F Expr)\n\n\n; (\\x. (if x then 0 else 1) + 2) false\n(define test\n    (App \n        (Abs \"x\" (Add (If (Var \"x\") (N 0) (N 1)) (N 2))) F))\n\n(datatype CExpr\n    (CVar String :cost 10000) ; (variables that haven't been eliminated yet)\n    (CAbs String CExpr :cost 10000) ; (abstractions that haven't been eliminated yet)\n    (CN i64)\n    (CApp CExpr CExpr))\n(declare CT CExpr)\n(declare CF CExpr)\n(declare CIf CExpr)\n(declare CAdd CExpr)\n(declare S CExpr)\n(declare K CExpr)\n(declare I CExpr)\n\n;;;; Conversion functions\n(function Comb (Expr) CExpr :cost 1000000)\n(function Uncomb (CExpr) Expr)    \n(rewrite (Comb (Uncomb cx)) cx)\n(rewrite (Uncomb (Comb x)) x)\n\n; Mechanical mappings back and forth.\n; Note: we avoid resugaring S/K/I\n(rule ((= x (N n))) ((set (Comb x) (CN n))))\n(rule ((= cx (CN n))) ((set (Uncomb cx) (N n))))\n(rule ((= x T)) ((set (Comb x) CT)))\n(rule ((= cx CT)) ((set (Uncomb cx) T)))\n(rule ((= x F)) ((set (Comb x) CF)))\n(rule ((= cx CF)) ((set (Uncomb cx) F)))\n\n(rule ((= x (If c t f)))\n    ((set (Comb x) (CApp (CApp (CApp CIf (Comb c)) (Comb t)) (Comb f)))))\n(rule ((= cx (CApp (CApp (CApp CIf cc) ct) cf)))\n    ((set (Uncomb cx) (If (Uncomb cc) (Uncomb ct) (Uncomb cf)))))\n\n(rule ((= x (Add l r)))\n    ((set (Comb x) (CApp (CApp CAdd (Comb l)) (Comb r)))))\n(rule ((= cx (CApp (CApp CAdd cl) cr)))\n    ((set (Uncomb cx) (Add (Uncomb cl) (Uncomb cr)))))\n(rule ((= x (App f a))) ((set (Comb x) (CApp (Comb f) (Comb a)))))\n\n(rule ((= x (Var v))) ((set (Comb x) (CVar v))))\n(rule ((= x (Abs v body))) ((set (Comb x) (CAbs v (Comb body)))))\n\n;;;; Abstraction Elimination \n(rewrite (CAbs v (CVar v)) I)\n; Hacks, could be replaced by !free computation.\n(rewrite (CAbs v1 (CVar v2)) (CApp K (CVar v2)) \n    :when ((!= v1 v2)))\n(rewrite (CAbs v (CN n)) (CApp K (CN n)))\n(rewrite (CAbs v CT) (CApp K CT))\n(rewrite (CAbs v CF) (CApp K CF))\n(rewrite (CAbs v CIf) (CApp K CIf))\n(rewrite (CAbs v CAdd) (CApp K CAdd))\n(rewrite (CAbs v (CApp x y)) (CApp (CApp S (CAbs v x)) (CAbs v y)))\n; May be needed for multiple nested variables\n(rewrite (CAbs v (CApp K (CVar v))) K)\n\n;;;; Primitive Evaluation rules (defined on \"surface syntax\")\n(rewrite (If T t f) t)\n(rewrite (If F t f) f)\n(rewrite (Add (N n) (N m)) (N (+ n m)))\n\n;;;; Substitution Rules (defined on the combinator representation)\n(rewrite (CApp I cx) cx)\n(rewrite (CApp (CApp K cx) cy) cx)\n; Without demand, this can cause an explosion in DB size.\n(rewrite (CApp (CApp (CApp S cx) cy) cz) (CApp (CApp cx cz) (CApp cy cz)))\n\n(run 11)\n(extract (Comb test))\n(check (= test (N 3)))",
  "cyk": "(datatype term (Term String))\n(datatype nonterm (NonTerm String))\n(datatype tree (NT String tree tree)\n                  (T String String))\n\n(function getString (i64) String)\n\n(relation Prod (nonterm nonterm nonterm))\n(relation End (nonterm String))\n\n\n\n(relation P (i64 i64 nonterm))\n(function B (i64 i64 nonterm) tree :cost 1000)\n\n(rule ((End (NonTerm a) s)\n       (= s (getString pos)))\n      ((P 1 pos (NonTerm a))\n       (set (B 1 pos (NonTerm a)) (T a s)))) \n\n(rule ((Prod (NonTerm a) (NonTerm b) (NonTerm c)) ;; a -> bc\n       (P p1 s (NonTerm b))\n       (P p2 (+ s p1) (NonTerm c)))\n      ((P (+ p1 p2) s (NonTerm a))))\n\n\n(rule ((Prod (NonTerm a) (NonTerm b) (NonTerm c))\n       (= f1 (B p1 s (NonTerm b)))\n       (= f2 (B p2 (+ s p1) (NonTerm c))))\n      ((set (B (+ p1 p2) s (NonTerm a)) \n       (NT a f1 f2))))\n\n(push)\n\n\n(set (getString 1) \"she\")\n(set (getString 2) \"eats\")\n(set (getString 3) \"a\")\n(set (getString 4) \"fish\")\n(set (getString 5) \"with\")\n(set (getString 6) \"a\")\n(set (getString 7) \"fork\")\n\n\n(Prod (NonTerm \"S\") (NonTerm \"NP\") (NonTerm \"VP\"))\n(Prod (NonTerm \"VP\") (NonTerm \"VP\") (NonTerm \"PP\"))\n(Prod (NonTerm \"VP\") (NonTerm \"V\") (NonTerm \"NP\"))\n(End (NonTerm \"VP\")  \"eats\")\n(Prod (NonTerm \"PP\") (NonTerm \"P\") (NonTerm \"NP\"))\n(Prod (NonTerm \"NP\") (NonTerm \"DET\") (NonTerm \"N\"))\n(End (NonTerm \"NP\") \"she\")\n(End (NonTerm \"V\") \"eats\")\n(End (NonTerm \"P\") \"with\")\n(End (NonTerm \"N\") \"fish\")\n(End (NonTerm \"N\") \"fork\")\n(End (NonTerm \"DET\") \"a\")\n\n\n(define test1 (B 7 1 (NonTerm \"S\")):cost 1000)\n\n(run 100)\n\n(check (P 7 1 (NonTerm \"S\")))\n(fail (check (P 7 1 (NonTerm \"VP\"))))\n(fail (check (P 7 1 (NonTerm \"\"))))\n\n(extract test1)\n(print test1)\n\n(pop)\n\n(push)\n\n(Prod (NonTerm \"S\") (NonTerm \"A\") (NonTerm \"B\"))\n(Prod (NonTerm \"S\") (NonTerm \"B\") (NonTerm \"C\"))\n(Prod (NonTerm \"A\") (NonTerm \"B\") (NonTerm \"A\"))\n(End (NonTerm \"A\") \"a\")\n(Prod (NonTerm \"B\") (NonTerm \"C\") (NonTerm \"C\"))\n(End (NonTerm \"B\") \"b\")\n(Prod (NonTerm \"C\") (NonTerm \"A\") (NonTerm \"B\"))\n(End (NonTerm \"C\") \"a\")\n\n(push)\n\n(set (getString 1) \"a\")\n(set (getString 2) \"b\")\n(set (getString 3) \"a\")\n(set (getString 4) \"a\")\n(set (getString 5) \"b\")\n\n(run 100)\n(check (P 5 1 (NonTerm \"S\")))\n(fail (check (P 5 1 (NonTerm \"B\"))))\n(define test2 (B 5 1 (NonTerm \"S\")):cost 1000)\n(extract:variants 10  test2)\n(print test2)\n\n(pop)\n\n(push)\n\n(set (getString 1) \"a\")\n(set (getString 2) \"a\")\n(set (getString 3) \"a\")\n(set (getString 4) \"a\")\n(set (getString 5) \"a\")\n\n(run 100)\n(check (P 5 1 (NonTerm \"S\")))\n(check (P 5 1 (NonTerm \"A\")))\n(fail (check (P 5 1 (NonTerm \"B\"))))\n(fail (check (P 5 1 (NonTerm \"\"))))\n(fail (check (P 5 1 (NonTerm \"unrelated\"))))\n(define test3 (B 5 1 (NonTerm \"S\")):cost 1000)\n(extract:variants 10 test3)\n(print test3) \n\n(pop)",
  "cykjson": "(datatype tree (NT String tree tree)\n                  (T String String))\n\n(function getString (i64) String)\n\n(relation Prod (String String String))\n(relation End (String String))\n\n\n(relation P (i64 i64 String))\n(function B (i64 i64 String) tree :cost 100000)\n\n(rule ((End a s)\n       (= s (getString pos)))\n      ((P 1 pos a)\n       (set (B 1 pos a) (T a s)))) \n\n(rule ((Prod a b c) ;; a -> bc\n       (P p1 s b)\n       (P p2 (+ s p1) c))\n      ((P (+ p1 p2) s a)))\n\n\n(rule ((Prod a b c)\n       (= f1 (B p1 s b))\n       (= f2 (B p2 (+ s p1) c)))\n      ((set (B (+ p1 p2) s a) \n       (NT a f1 f2))))\n\n\n(input Prod \"./tests/cykjson_Prod.csv\")\n(input End \"./tests/cykjson_End.csv\")\n\n; small size 801\n(input getString \"./tests/cykjson_small_token.csv\")\n\n; medium size 7821 but runs for 2 min.\n;(input getString \"./tests/cykjson_medium_token.csv\")\n\n(define test1 (B 801 1 \"VAL\"):cost 100000)\n\n(run 10000)\n\n(check (P 801 1 \"VAL\"))",
  "delete": "(function foo (i64) i64)\n(set (foo 1) 7)\n(check (= (foo 1) 7))\n(delete (foo 1))\n(rule ((= x (foo 1))) ((panic \"foo 1 was there!\")))\n(run 1)",
  "eqsat-basic": "(datatype Math\n  (Num i64)\n  (Var String)\n  (Add Math Math)\n  (Mul Math Math))\n\n;; expr1 = 2 * (x + 3)\n(define expr1 (Mul (Num 2) (Add (Var \"x\") (Num 3)))) \n;; expr2 = 6 + 2 * x\n(define expr2 (Add (Num 6) (Mul (Num 2) (Var \"x\"))))\n\n\n;; (rule ((= __root (Add a b)))\n;;       ((union __root (Add b a)))\n(rewrite (Add a b)\n         (Add b a))\n(rewrite (Mul a (Add b c))\n         (Add (Mul a b) (Mul a c)))\n(rewrite (Add (Num a) (Num b)) \n         (Num (+ a b)))\n(rewrite (Mul (Num a) (Num b))\n         (Num (* a b)))\n\n(run 10)\n(check (= expr1 expr2))",
  "eqsolve": "(datatype Expr\n  (Add Expr Expr)\n  (Neg Expr)\n  (Num i64)\n  (Mul Expr Expr)\n  (Var String)\n)\n\n(rewrite (Add x y) (Add y x))\n(rewrite (Add (Add x y) z) (Add x (Add y z)))\n(rewrite (Add (Num x) (Num y)) (Num (+ x y)))\n(rule ((= (Add x y) z))\n      ((union (Add z (Neg y)) x)))\n(rewrite (Neg (Neg x)) x)\n(rewrite (Neg (Num n)) (Num (- 0 n)))\n\n(rule ((= x (Var v))) ((union (Mul (Num 1) x) x)))\n(rule ((= x (Add x1 x2))) ((union (Mul (Num 1) x) x)))\n(rewrite (Add (Mul y x) (Mul z x)) (Mul (Add y z) x))\n(rewrite (Mul x y) (Mul y x))\n(rule ((= (Mul (Num x) y) (Num z))\n       (= (% z x) 0))\n      ((union y (Num (/ z x)))))\n\n; system 1: x + 2 = 7\n(set (Add (Var \"x\") (Num 2)) (Num 7))\n; system 2: z + y = 6, 2z = y\n(set (Add (Var \"z\") (Var \"y\")) (Num 6))\n(set (Add (Var \"z\") (Var \"z\")) (Var \"y\"))\n\n(run 5)\n(extract (Var \"x\"))\n(extract (Var \"y\"))\n(extract (Var \"z\"))\n(check (= (Var \"z\") (Add (Num 6) (Neg (Var \"y\")))))\n(check (= (Var \"y\") (Add (Add (Num 6) (Neg (Var \"y\"))) (Add (Num 6) (Neg (Var \"y\"))))))\n(check (= (Var \"y\") (Add (Add (Num 12) (Neg (Var \"y\"))) (Neg (Var \"y\")))))\n(check (= (Add (Var \"y\") (Var \"y\")) \n          (Add (Num 12) (Neg (Var \"y\")))))\n(check (= (Add (Add (Var \"y\") (Var \"y\")) (Var \"y\"))\n          (Num 12)))\n(check (= (Add (Mul (Num 2) (Var \"y\")) (Var \"y\"))\n          (Num 12)))\n(check (= (Mul (Num 3) (Var \"y\"))\n          (Num 12)))\n",
  "extraction-cost": "(datatype Expr\n  (Num i64 :cost 5))\n\n(define x (Num 1) :cost 10)\n(define y (Num 2) :cost 1)\n\n(extract x) ;; (Num 1)\n(extract y) ;; (y)",
  "f64": "(check (= (+ 1.5 9.2) 10.7))\n(check (= (/ 12.5 2.0) 6.25))\n(check (< 1.5 9.2))\n(check (>= 9.2 1.5))\n",
  "unbound": "(datatype Math\n    (Add Math Math)\n    (Sub Math Math)\n)\n\n(rule ((= e (Add x y))) ((Add x i)))\n",
  "fail_wrong_assertion": ";; This test ensure check test fails for wrong assertion\n(function f (i64) i64 :merge (min old new))\n\n(set (f 1) 4)\n(set (f 1) 5)\n\n(check (= (f 1) 4))\n(fail (check (= (f 1) 2)))\n\n(delete (f 1))\n(fail (check (= (f 1) 4)))\n\n(function g (i64 i64) i64 :merge (min old new))\n\n(set (g 1 2) 3)\n(set (g 2 3) 3)\n\n(check (= (g 1 2) (g 2 3)))\n(fail (check (!= (g 1 2) (g 2 3))))\n(fail (check (= (g 0 2) (g 2 3))))\n(check (= x (g 1 2)))\n(fail (check (= x (g 1 3))))\n(check (= x (g 1 2)) (= y (g 2 3)) (= x y))\n(fail (check (= x (g 0 0)) (= y (g 1 1)) (= x y)))",
  "fibonacci-demand": "(datatype Expr \n  (Num i64)\n  (Add Expr Expr))\n\n(function Fib (i64) Expr)\n\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rewrite (Fib x) (Add (Fib (- x 1)) (Fib (- x 2)))\n         :when ((> x 1)))\n(rewrite (Fib x) (Num x)\n         :when ((<= x 1)))\n\n(define f7 (Fib 7))\n(run 1000)\n(extract f7)\n(check (= f7 (Num 13)))\n       \n ",
  "fibonacci": "(function fib (i64) i64)\n(set (fib 0) 0)\n(set (fib 1) 1)\n\n(rule ((= f0 (fib x))\n       (= f1 (fib (+ x 1))))\n      ((set (fib (+ x 2)) (+ f0 f1))))\n\n(run 7)\n\n(check (= (fib 7) 13))",
  "fusion": "(datatype Var)\n(datatype Term\n    (App Term Term)\n    (Lam Var Term)\n    (TVar Var)\n    (Let Var Term Term)\n    (Add Term Term)\n    (Num i64)\n    (CaseSplit Term Term Term)\n    (Cons Term Term))\n(declare Nil Term)\n\n(function V (String) Var) \n(function From (Term) Var)\n\n;; ==== FV ====\n(sort StringSet (Map Var i64))\n(function freer (Term) StringSet :merge (set-intersect old new))\n(rule ((= e (App e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Lam var body))\n       (= (freer body) fv))\n      ((set (freer e) (map-remove fv var))))\n(rule ((= e (TVar v)))\n      ((set (freer e) (insert (empty) v 1))))\n(rule ((= e (Let var e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union (map-remove fv1 var) fv2))))\n(rule ((= e (Add e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Num v)))\n      ((set (freer e) (empty))))\n(rule ((= e (CaseSplit e1 e2 e3))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2)\n       (= (freer e3) fv3))\n      ((set (freer e) (set-union (set-union fv1 fv2) fv3))))\n(rule ((= e (Cons e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e Nil))\n      ((set (freer e) (empty))))\n\n;; ==== eval ====\n; beta\n(rewrite (App (Lam v body) e) (Let v e body))\n; case-split-nil\n(rewrite (CaseSplit Nil e1 e2) e1)\n; case-split-cons\n(rewrite (CaseSplit (Cons x xs) e1 e2) (App (App e2 x) xs))\n\n; let-num\n(rewrite (Let v e (Num n)) (Num n))\n; let-nil\n(rewrite (Let v e Nil) Nil)\n; let-var-same\n(rewrite (Let v1 e (TVar v1)) e)\n; let-var-diff\n(rewrite (Let v1 e (TVar v2)) (TVar v2) :when ((!= v1 v2)))\n\n; let-lam-close\n(rewrite (Let v1 e expr) expr :when ((not-contains (freer expr) v1)))      \n; let-app\n(rewrite (Let v e expr) (App (Let v e a) (Let v e b)) :when ((= expr (App a b)) (contains (freer expr) v)))\n; let-add\n(rewrite (Let v e expr) (Add (Let v e a) (Let v e b)) :when ((= expr (Add a b)) (contains (freer expr) v)))\n; let-cons\n(rewrite (Let v e expr) (Cons (Let v e x) (Let v e xs)) :when ((= expr (Cons x xs)) (contains (freer expr) v)))\n; let-case-split\n(rewrite (Let v e expr) \n         (CaseSplit (Let v e e1) (Let v e e2) (Let v e e3))\n    :when ((= expr (CaseSplit e1 e2 e3))\n           (contains (freer expr) v)))\n; let-lam-same\n(rewrite (Let v1 e (Lam v1 body)) (Lam v1 body))\n; let-lam-diff\n(rewrite (Let v1 e (Lam v2 body)) (Lam v2 (Let v1 e body))\n      :when ((contains (freer body) v1)\n             (!= v1 v2)\n             (= fvs (freer e))\n             (not-contains fvs v2)))\n(rule ((= expr (Let v1 e (Lam v2 body)))\n       (contains (freer body) v1)\n       (!= v1 v2)\n       (= fvs (freer e))\n       (contains fvs v2))\n      ((union expr (Lam (From expr) (Let v1 e (Let v2 (TVar (From expr)) body))))))\n\n(function pushdown (Term Term) Term :cost 10000)\n(rewrite (App f (App (Lam x e) e2))\n         (App (Lam x (pushdown f e)) e2))\n\n(rewrite (pushdown f (CaseSplit e e1 (Lam x (Lam xs e2)))) \n         (CaseSplit e (App f e1) (Lam x (Lam xs (App f e2)))))\n\n(relation is-tail (Term))\n(rule ((= demand (pushdown f e)) (= e (App e1 e2))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (Lam x e))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (TVar x))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (Cons e1 e2))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e Nil)) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (Add e1 e2))) ((is-tail e)))\n(rule ((= demand (pushdown f e)) (= e (Num n1))) ((is-tail e)))\n(rewrite (pushdown f e) (App f e) :when ((is-tail e)))\n\n;; ==== definition ====\n\n(function sum () Term :cost 1000)\n(function mapf () Term :cost 1000)\n(function sum-o-mapf () Term)\n(rewrite (App (sum) (App (mapf) x)) (App (sum-o-mapf) x))\n(union (sum) (Lam (V \"xs\")\n    (CaseSplit (TVar (V \"xs\")) \n        (Num 0)\n        (Lam (V \"x\") (Lam (V \"xs'\") \n            (Add (TVar (V \"x\")) (App (sum) (TVar (V \"xs'\")))))))))\n\n(union (mapf) (Lam (V \"xs\")\n    (CaseSplit (TVar (V \"xs\"))\n        Nil\n        (Lam (V \"x\") (Lam (V \"xs'\")\n            (Cons (Add (TVar (V \"x\")) (Num 1))\n                  (App (mapf) (TVar (V \"xs'\")))))))))\n\n(set (freer (sum)) (empty))\n(set (freer (mapf)) (empty))\n\n(define expr (App (sum) (App (mapf) (TVar (V \"expr\")))))\n\n(run 100)\n\n(define my-output\n    (CaseSplit (TVar (V \"expr\")) (Num 0) \n           (Lam (V \"x\") (Lam (V \"xs'\") \n                (Add (Add (TVar (V \"x\")) (Num 1)) \n                     (App (sum-o-mapf) (TVar (V \"xs'\"))))))))\n\n(check (= (App (sum-o-mapf) (TVar (V \"expr\")))\n          (CaseSplit (TVar (V \"expr\")) (Num 0) \n                 (Lam (V \"x\") (Lam (V \"xs'\") \n                      (Add (Add (TVar (V \"x\")) (Num 1)) \n                           (App (sum-o-mapf) (TVar (V \"xs'\")))))))))\n",
  "herbie": ";; Implements part of the simplification layer of herbie in egg-smol\ud83e\udee1\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Datatypes\n\n(datatype Math\n  ; Ground terms\n  (Num Rational)\n  (Var String)\n\n  ; Custom ops\n  (Const String)\n  (Unary String Math)\n  ; unneeded for now\n  ; (Binary String Math Math)\n\n  ; Constant-folding ops\n  (Add Math Math)\n  (Sub Math Math)\n  (Mul Math Math)\n  (Div Math Math)\n  (Pow Math Math)\n  (Neg Math)\n  (Sqrt Math)\n  (Cbrt Math) ; cube root\n  (Fabs Math)\n  (Ceil Math)\n  (Floor Math)\n  (Round Math)\n  (Log Math))\n\n(define r-zero (rational 0 1))\n(define r-one  (rational 1 1))\n(define r-two  (rational 2 1))\n(define zero (Num r-zero))\n(define one  (Num r-one))\n(define two  (Num r-two))\n(define three (Num (rational 3 1)))\n(define neg-one (Neg one))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Analyses\n;; --------\n;; This example has three analyses:\n;; an interval analysis consisting of a hi and lo component\n;; and a non-zero analysis.\n;; The non-zero analysis is built off the interval analysis (in order to prove\n;; that rewrites are sound, even if some parts of an expr can't be const-evaled)\n\n; TODO: unbounded intervals?\n(function hi (Math) Rational :merge (min old new))\n(function lo (Math) Rational :merge (max old new))\n(relation non-zero (Math))\n\n;; First, constant folding!\n;; We don't need an explicit constant folding analysis, we can just union\n;; with nums when we can\n\n; Cases\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rewrite (Sub (Num a) (Num b)) (Num (- a b)))\n(rewrite (Mul (Num a) (Num b)) (Num (* a b)))\n(rewrite (Div (Num a) denom) (Num (/ a b)) :when ((= denom (Num b)) (non-zero denom)))\n(rewrite (Pow (Num a) (Num b)) (Num res) :when ((= res (pow a b))))\n(rewrite (Neg (Num a)) (Num (neg a)))\n;; TODO unimplemented\n;; (rewrite (Sqrt (Num a)) (Num res) :when ((= res (sqrt a))))\n;; (rewrite (Cbrt (Num a)) (Num res) :when ((= res (cbrt a))))\n(rewrite (Fabs (Num a)) (Num (abs a)))\n(rewrite (Ceil (Num a)) (Num (ceil a)))\n(rewrite (Floor (Num a)) (Num (floor a)))\n(rewrite (Round (Num a)) (Num (round a)))\n(rewrite (Log (Num a)) (Num res) :when ((= res (log a))))\n\n;; To check if something is zero, we check that zero is not contained in the\n;; interval. There are two possible (overlapping!) cases:\n;; - There exists a lo interval, in which case it must be larger than 0\n;; - There exists a hi interval, in which case it must be smaller than 0\n;; This assumes that intervals are well-formed: lo <= hi at all times.\n(rule ((= l (lo e))\n       (> l r-zero))\n      ((non-zero e)))\n(rule ((= h (hi e))\n       (< h r-zero))\n      ((non-zero e)))\n\n(rule ((= e (Num ve)))\n      ((set (lo e) ve)\n       (set (hi e) ve)))\n\n;; The interval analyses are similar to the constant-folding analysis,\n;; except we have to take the lower/upper bound of the results we get\n(rule ((= e (Add a b))\n       (= la (lo a))\n       (= lb (lo b)))\n      ((set (lo e) (+ la lb))))\n(rule ((= e (Add a b))\n       (= ha (hi a))\n       (= hb (hi b)))\n      ((set (hi e) (+ ha hb))))\n      \n(rule ((= e (Sub a b))\n       (= la (lo a))\n       (= ha (hi a))\n       (= lb (lo b))\n       (= hb (hi b)))\n      ((set (lo e) \n          (min (min (- la lb) (- la hb))\n               (min (- ha lb) (- ha hb))))\n       (set (hi e) \n          (max (max (- la lb) (- la hb))\n               (max (- ha lb) (- ha hb))))))\n\n(rule ((= e (Mul a b))\n       (= la (lo a))\n       (= ha (hi a))\n       (= lb (lo b))\n       (= hb (hi b)))\n      ((set (lo e) \n          (min (min (* la lb) (* la hb))\n               (min (* ha lb) (* ha hb))))\n       (set (hi e) \n          (max (max (* la lb) (* la hb))\n               (max (* ha lb) (* ha hb))))))\n\n(rule ((= e (Div a b))\n       (= la (lo a))\n       (= ha (hi a))\n       (= lb (lo b))\n       (= hb (hi b)))\n      ((set (lo e) \n          (min (min (/ la lb) (/ la hb))\n               (min (/ ha lb) (/ ha hb))))\n       (set (hi e) \n          (max (max (/ la lb) (/ la hb))\n               (max (/ ha lb) (/ ha hb))))))\n\n; TODO: Pow\n\n(rule ((= e (Neg a))\n       (= la (lo a))\n       (= ha (hi a)))\n      ((set (lo e) (neg ha))\n       (set (hi e) (neg la))))\n\n; TODO: Sqrt\n; TODO: Cbrt\n\n(rule ((= e (Fabs a))\n       (= la (lo a))\n       (= ha (hi a)))\n      ((set (lo e) (min (abs la) (abs ha)))\n       (set (hi e) (max (abs la) (abs ha)))))\n\n(rule ((= e (Ceil a))\n       (= la (lo a)))\n      ((set (lo e) (ceil la))))\n(rule ((= e (Ceil a))\n       (= ha (hi a)))\n      ((set (hi e) (ceil ha))))\n\n(rule ((= e (Floor a))\n       (= la (lo a)))\n      ((set (lo e) (floor la))))\n(rule ((= e (Floor a))\n       (= ha (hi a)))\n      ((set (hi e) (floor ha))))\n\n(rule ((= e (Round a))\n       (= la (lo a)))\n      ((set (lo e) (round la))))\n(rule ((= e (Round a))\n       (= ha (hi a)))\n      ((set (hi e) (round ha))))\n\n; TODO: Log\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Rewrites\n;; --------\n;; These rewrites were compiled from src/syntax/rules.rkt in the herbie repo,\n;; using all rewrites in the `simplify` rewrite group.\n\n;; Commutativity\n(rewrite (Add a b) (Add b a))\n(rewrite (Mul a b) (Mul b a))\n\n;; Associativity\n(rewrite (Add a (Add b c)) (Add (Add a b) c))\n(rewrite (Add (Add a b) c) (Add a (Add b c)))\n(rewrite (Add a (Sub b c)) (Sub (Add a b) c))\n(rewrite (Add (Sub a b) c) (Sub a (Sub b c)))\n(rewrite (Sub a (Add b c)) (Sub (Sub a b) c))\n(rewrite (Sub (Add a b) c) (Add a (Sub b c)))\n(rewrite (Sub (Sub a b) c) (Sub a (Add b c)))\n(rewrite (Sub a (Sub b c)) (Add (Sub a b) c))\n(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))\n(rewrite (Mul (Mul a b) c) (Mul a (Mul b c)))\n(rewrite (Mul a (Div b c)) (Div (Mul a b) c))\n(rewrite (Mul (Div a b) c) (Div (Mul a c) b))\n(rewrite (Div a (Mul b c)) (Div (Div a b) c))\n(rewrite (Div (Mul b c) a) (Div b (Div a c)) :when ((non-zero c)))\n(rewrite (Div a (Div b c)) (Mul (Div a b) c) :when ((non-zero c)))\n(rewrite (Div (Div b c) a) (Div b (Mul a c)) :when ((non-zero a)))\n\n;; Counting\n(rewrite (Add x x) (Mul two x))\n\n;; Distributivity\n(rewrite (Mul a (Add b c))         (Add (Mul a b) (Mul a c)))\n(rewrite (Mul a (Add b c))         (Add (Mul b a) (Mul c a)))\n(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))\n(rewrite (Sub (Mul a b) (Mul a c)) (Mul a (Sub b c)))\n(rewrite (Add (Mul b a) (Mul c a)) (Mul a (Add b c)))\n(rewrite (Sub (Mul b a) (Mul c a)) (Mul a (Sub b c)))\n(rewrite (Add (Mul b a) a)         (Mul (Add b one) a))\n(rewrite (Add a (Mul c a))         (Mul (Add c one) a))\n\n(rewrite (Neg (Mul a b))       (Mul (Neg a) b))\n(rewrite (Neg (Mul a b))       (Mul a (Neg b)))\n(rewrite (Mul (Neg a) b)       (Neg (Mul a b)))\n(rewrite (Mul a (Neg b))       (Neg (Mul a b)))\n(rewrite (Neg (Add a b))       (Add (Neg a) (Neg b)))\n(rewrite (Add (Neg a) (Neg b)) (Neg (Add a b)))\n(rewrite (Div (Neg a) b)       (Neg (Div a b)))\n(rewrite (Neg (Div a b))       (Div (Neg a) b))\n\n(rewrite (Sub a (Mul (Neg b) c)) (Add a (Mul b c)))\n(rewrite (Sub a (Mul b c))       (Add a (Mul (Neg b) c)))\n\n;; Difference of squares\n(rewrite (Mul (Mul a b) (Mul a b))                           (Mul (Mul a a) (Mul b b)))\n(rewrite (Mul (Mul a a) (Mul b b))                           (Mul (Mul a b) (Mul a b)))\n(rewrite (Sub (Mul a a) (Mul b b))                           (Mul (Add a b) (Sub a b)))\n(rewrite (Sub (Mul a a) one)                (Mul (Add a one) (Sub a one)))\n(rewrite (Add (Mul a a) (Neg one))          (Mul (Add a one) (Sub a one)))\n(rewrite (Pow a b) (Mul (Pow a (Div b two)) (Pow a (Div b two))))\n(rewrite (Mul (Pow a b) (Pow a b))                           (Pow a (Mul two b)))\n\n;; Identity\n;; This isn't subsumed by const folding since this can return results\n;; even if we can't evaluate a precise value for x\n(rewrite (Div one (Div one x))\n         x\n         :when ((non-zero x)))\n(rewrite (Mul x (Div one x))\n         one\n         :when ((non-zero x)))\n(rewrite (Mul (Div one x) x)\n         one\n         :when ((non-zero x)))\n\n(rewrite (Sub x x) zero)\n(rewrite (Div x x) one\n         :when ((non-zero x)))\n(rewrite (Div zero x) zero\n         :when ((non-zero x)))\n(rewrite (Mul zero x) zero)\n(rewrite (Mul x zero) zero)\n\n(rewrite (Add zero x) x)\n(rewrite (Add x zero) x)\n(rewrite (Sub zero x) (Neg x))\n(rewrite (Sub x zero) x)\n(rewrite (Neg (Neg x)) x)\n(rewrite (Mul one x) x)\n(rewrite (Mul x one) x)\n(rewrite (Div x one) x)\n(rewrite (Mul neg-one x) (Neg x))\n \n(rewrite (Sub a b) (Add a (Neg b)))\n(rewrite (Add a (Neg b)) (Sub a b))\n(rewrite (Neg x) (Sub zero x))\n(rewrite (Neg x) (Mul neg-one x))\n\n(rewrite (Div x y) (Mul x (Div one y)))\n(rewrite (Mul x (Div one y)) (Div x y))\n(rewrite (Div x y) (Div one (Div y x))\n  :when ((non-zero x)\n         (non-zero y)))\n\n; FIXME: this rule can't be expressed in its full generality;\n;        we can't express the general rule x -> 1/x since\n;        we can't quantify over Math yet\n;        for now we just apply it to vars\n;        it's also p slow lmao\n(rewrite (Var x) (Mul one (Var x)))\n\n;; Fractions\n(rewrite (Div (Sub a b) c)         (Sub (Div a c) (Div b c)))\n(rewrite (Div (Mul a b) (Mul c d)) (Mul (Div a c) (Div b d)))\n\n;; Square root\n(rewrite (Mul (Sqrt x) (Sqrt x)) x)\n(rewrite (Sqrt (Mul x x)) (Fabs x))\n\n(rewrite (Mul (Neg x) (Neg x)) (Mul x x))\n(rewrite (Mul (Fabs x) (Fabs x)) (Mul x x))\n\n;; Absolute values\n(rewrite (Fabs (Fabs x)) (Fabs x))\n(rewrite (Fabs (Sub a b)) (Fabs (Sub b a)))\n(rewrite (Fabs (Neg x)) (Fabs x))\n(rewrite (Fabs (Mul x x)) (Mul x x))\n(rewrite (Fabs (Mul a b)) (Mul (Fabs a) (Fabs b)))\n(rewrite (Fabs (Div a b)) (Div (Fabs a) (Fabs b)))\n\n;; Cube root\n(rewrite (Pow (Cbrt x) three)    x)\n(rewrite (Cbrt (Pow x three))    x)\n(rewrite (Mul (Mul (Cbrt x) (Cbrt x)) (Cbrt x)) x)\n(rewrite (Mul (Cbrt x) (Mul (Cbrt x) (Cbrt x))) x)\n(rewrite (Pow (Neg x) three)     (Neg (Pow x three)))\n\n(rewrite (Pow (Mul x y) three)\n         (Mul (Pow x three) (Pow y three)))\n(rewrite (Pow (Div x y) three)\n         (Div (Pow x three) (Pow y three)))\n \n(rewrite (Pow x three) (Mul x (Mul x x)))\n; FIXME: this rewrite is slow and has the potential to blow up the egraph\n;        this is bc this rule and the second-to-last difference of squares rule\n;        have some cyclic behavior goin on\n;        the last identity rule compounds this behavior\n(rewrite (Mul x (Mul x x)) (Pow x three))\n\n;; Exponentials\n(rewrite (Unary \"exp\" (Log x)) x)\n(rewrite (Log (Unary \"exp\" x)) x)\n\n(rewrite (Unary \"exp\" zero) one)\n(rewrite (Unary \"exp\" one) (Const \"E\"))\n;; (rewrite one               (Unary \"exp\" zero))\n(rewrite (Const \"E\")       (Unary \"exp\" one))\n\n(rewrite (Unary \"exp\" (Add a b)) (Mul (Unary \"exp\" a) (Unary \"exp\" b)))\n(rewrite (Unary \"exp\" (Sub a b)) (Div (Unary \"exp\" a) (Unary \"exp\" b)))\n(rewrite (Unary \"exp\" (Neg a))   (Div one (Unary \"exp\" a)))\n\n(rewrite (Mul (Unary \"exp\" a) (Unary \"exp\" b))      (Unary \"exp\" (Add a b)))\n(rewrite (Div one (Unary \"exp\" a)) (Unary \"exp\" (Neg a)))\n(rewrite (Div (Unary \"exp\" a) (Unary \"exp\" b))      (Unary \"exp\" (Sub a b)))\n(rewrite (Unary \"exp\" (Mul a b))                    (Pow (Unary \"exp\" a) b))\n(rewrite (Unary \"exp\" (Div a two)) (Sqrt (Unary \"exp\" a)))\n(rewrite (Unary \"exp\" (Div a three)) (Cbrt (Unary \"exp\" a)))\n(rewrite (Unary \"exp\" (Mul a two)) (Mul (Unary \"exp\" a) (Unary \"exp\" a)))\n(rewrite (Unary \"exp\" (Mul a three)) (Pow (Unary \"exp\" a) three))\n\n;; Powers\n(rewrite (Pow a neg-one) (Div one a))\n(rewrite (Pow a one) a)\n\n; 0^0 is undefined\n(rewrite (Pow a zero) one :when ((non-zero a)))\n(rewrite (Pow one a) one)\n\n(rewrite (Unary \"Exp\" (Mul (Log a) b)) (Pow a b))\n(rewrite (Mul (Pow a b) a) (Pow a (Add b one)))\n(rewrite (Pow a (Num (rational 1 2))) (Sqrt a))\n(rewrite (Pow a two) (Mul a a))\n(rewrite (Pow a (Num (rational 1 3))) (Cbrt a))\n(rewrite (Pow a three) (Mul (Mul a a) a))\n\n; 0^0 is undefined\n(rewrite (Pow zero a) zero :when ((non-zero a)))\n\n;; Logarithms\n(rewrite (Log (Mul a b)) (Add (Log a) (Log b)))\n(rewrite (Log (Div a b)) (Sub (Log a) (Log b)))\n(rewrite (Log (Div one a)) (Neg (Log a)))\n(rewrite (Log (Pow a b)) (Mul b (Log a)))\n(rewrite (Log (Const \"E\")) one)\n\n;; Trigonometry\n(rewrite (Add (Mul (Unary \"cos\" a) (Unary \"cos\" a)) (Mul (Unary \"sin\" a) (Unary \"sin\" a)))\n         one)\n(rewrite (Sub one (Mul (Unary \"cos\" a) (Unary \"cos\" a)))\n         (Mul (Unary \"sin\" a) (Unary \"sin\" a)))\n(rewrite (Sub one (Mul (Unary \"sin\" a) (Unary \"sin\" a)))\n         (Mul (Unary \"cos\" a) (Unary \"cos\" a)))\n(rewrite (Add (Mul (Unary \"cos\" a) (Unary \"cos\" a)) (Num (rational -1 1))) \n         (Neg (Mul (Unary \"sin\" a) (Unary \"sin\" a))))\n(rewrite (Add (Mul (Unary \"sin\" a) (Unary \"sin\" a)) (Num (rational -1 1))) \n         (Neg (Mul (Unary \"cos\" a) (Unary \"cos\" a))))\n(rewrite (Sub (Mul (Unary \"cos\" a) (Unary \"cos\" a)) one)  \n         (Neg (Mul (Unary \"sin\" a) (Unary \"sin\" a))))\n(rewrite (Sub (Mul (Unary \"sin\" a) (Unary \"sin\" a)) one)  \n         (Neg (Mul (Unary \"cos\" a) (Unary \"cos\" a))))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") (Num (rational 6 1))))       \n         (Num (rational 1 2)))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") (Num (rational 4 1))))       \n         (Div (Sqrt two) two))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") three))       \n         (Div (Sqrt three) two))\n(rewrite (Unary \"sin\" (Div (Const \"PI\") two))       \n         one)\n(rewrite (Unary \"sin\" (Const \"PI\"))             \n         zero)\n(rewrite (Unary \"sin\" (Add x (Const \"PI\")))       \n         (Neg (Unary \"sin\" x)))\n(rewrite (Unary \"sin\" (Add x (Div (Const \"PI\") two))) \n         (Unary \"cos\" x))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") (Num (rational 6 1))))       \n         (Div (Sqrt three) two))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") (Num (rational 4 1))))       \n         (Div (Sqrt two) two))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") three))       \n         (Num (rational 1 2)))\n(rewrite (Unary \"cos\" (Div (Const \"PI\") two))       \n         zero)\n(rewrite (Unary \"cos\" (Const \"PI\"))             \n         (Num (rational -1 1)))\n(rewrite (Unary \"cos\" (Add x (Const \"PI\")))       \n         (Neg (Unary \"cos\" x)))\n(rewrite (Unary \"cos\" (Add x (Div (Const \"PI\") two))) \n         (Neg (Unary \"sin\" x)))\n(rewrite (Unary \"tan\" (Div (Const \"PI\") (Num (rational 6 1))))       \n         (Div one (Sqrt three)))\n(rewrite (Unary \"tan\" (Div (Const \"PI\") (Num (rational 4 1))))       \n         one)\n(rewrite (Unary \"tan\" (Div (Const \"PI\") three))       \n         (Sqrt three))\n(rewrite (Unary \"tan\" (Const \"PI\"))             \n         zero)\n(rewrite (Unary \"tan\" (Add x (Const \"PI\")))       \n         (Unary \"tan\" x))\n(rewrite (Unary \"tan\" (Add x (Div (Const \"PI\") two))) \n         (Div neg-one (Unary \"tan\" x)))\n(rewrite (Div (Unary \"sin\" a) (Add one (Unary \"cos\" a)))    \n         (Unary \"tan\" (Div a two)))\n(rewrite (Div (Neg (Unary \"sin\" a)) (Add one (Unary \"cos\" a)))\n         (Unary \"tan\" (Div (Neg a) two)))\n(rewrite (Div (Sub one (Unary \"cos\" a)) (Unary \"sin\" a))    \n         (Unary \"tan\" (Div a two)))\n(rewrite (Div (Sub one (Unary \"cos\" a)) (Neg (Unary \"sin\" a)))\n         (Unary \"tan\" (Div (Neg a) two)))\n(rewrite (Div (Add (Unary \"sin\" a) (Unary \"sin\" b)) (Add (Unary \"cos\" a) (Unary \"cos\" b)))\n         (Unary \"tan\" (Div (Add a b) two)))\n(rewrite (Div (Sub (Unary \"sin\" a) (Unary \"sin\" b)) (Add (Unary \"cos\" a) (Unary \"cos\" b)))\n         (Unary \"tan\" (Div (Sub a b) two)))\n\n(rewrite (Unary \"sin\" zero) zero)\n(rewrite (Unary \"cos\" zero) one)\n(rewrite (Unary \"tan\" zero) zero)\n\n(rewrite (Unary \"sin\" (Neg x)) (Neg (Unary \"sin\" x)))\n(rewrite (Unary \"cos\" (Neg x)) (Unary \"cos\" x))\n(rewrite (Unary \"tan\" (Neg x)) (Neg (Unary \"cos\" x)))\n\n; Hyperbolics\n(rewrite (Unary \"sinh\" x) (Div (Sub (Unary \"exp\" x) (Unary \"exp\" (Neg x))) two))\n(rewrite (Unary \"cosh\" x) (Div (Add (Unary \"exp\" x) (Unary \"exp\" (Neg x))) two))\n(rewrite (Unary \"tanh\" x) (Div (Sub (Unary \"exp\" x) (Unary \"exp\" (Neg x))) (Add (Unary \"exp\" x) (Unary \"exp\" (Neg x)))))\n(rewrite (Unary \"tanh\" x) (Div (Sub (Unary \"exp\" (Mul two x)) one) (Add (Unary \"exp\" (Mul two x)) one)))\n(rewrite (Unary \"tanh\" x) (Div (Sub one (Unary \"exp\" (Mul (Num (rational -2 1)) x))) (Add one (Unary \"exp\" (Mul (Num (rational -2 1)) x)))))\n(rewrite (Sub (Mul (Unary \"cosh\" x) (Unary \"cosh\" x)) (Mul (Unary \"sinh\" x) (Unary \"sinh\" x))) one)\n(rewrite (Add (Unary \"cosh\" x) (Unary \"sinh\" x)) (Unary \"exp\" x))\n(rewrite (Sub (Unary \"cosh\" x) (Unary \"sinh\" x)) (Unary \"exp\" (Neg x)))\n\n;; Unimplemented: misc. rewrites (conditionals, specialized numerical fns)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Testing\n;; -------\n;; In actuality, herbie would be responsible for plugging exprs in here.\n;; For our purposes, we take some test cases from herbie\n;; (src/core/simplify.rkt)\n\n(push)\n(define e (Add one zero))\n(run 1)\n(check (= e one))\n(pop)\n\n(push)\n(define five (Num (rational 5 1)))\n(define six (Num (rational 6 1)))\n(define e2 (Add one five))\n(run 1)\n(check (= e2 six))\n(pop)\n\n(define x (Var \"x\"))\n\n(push)\n(define e3 (Add x zero))\n(run 1)\n(check (= e3 x))\n(pop)\n\n(push)\n(define e4 (Sub x zero))\n(run 1)\n(check (= e4 x))\n(pop)\n\n(push)\n\n(define e5 (Mul x one))\n(run 1)\n(check (= e5 x))\n(pop)\n\n(push)\n\n(define e6 (Div x one))\n(run 1)\n(check (= e6 x))\n(pop)\n\n(push)\n\n(define e7 (Sub (Mul one x) (Mul (Add x one) one)))\n(run 3)\n(check (= e7 (Num (rational -1 1))))\n(pop)\n\n(push)\n\n(define e8 (Sub (Add x one) x))\n(run 4)\n(check (= e8 one))\n(pop)\n\n(push)\n\n(define e9 (Sub (Add x one) one))\n(run 4)\n(check (= e9 x))\n(pop)\n\n(push)\n\n(set (lo x) r-one)\n(define e10 (Div (Mul x three) x))\n(run 3)\n(check (= e10 three))\n(pop)\n\n(push)\n\n(define e11 (Sub (Mul (Sqrt (Add x one)) (Sqrt (Add x one))) (Mul (Sqrt x) (Sqrt x))))\n(run 5)\n(check (= one e11))\n(pop)\n\n(push)\n(define e12 (Add (Num (rational 1 5)) (Num (rational 3 10))))\n(run 1)\n(check (= e12 (Num (rational 1 2))))\n(pop)\n\n(push)\n(define e13 (Unary \"cos\" (Const \"PI\")))\n(run 1)\n(check (= e13 (Num (rational -1 1))))\n(pop)\n\n(push)\n(define sqrt5 (Sqrt (Num (rational 5 1))))\n(define e14\n  (Div one (Sub (Div (Add one sqrt5) two) (Div (Sub one sqrt5) two))))\n(define tgt (Div one sqrt5))\n(run 6)\n(check (= e14 tgt))\n(pop)",
  "include": "(include \"tests/path.egg\")\n(check (path 1 3))\n",
  "intersection": ";; computes \"e-graph intersection\"\n\n(datatype Expr\n    (Var String)\n    (f Expr))\n\n(function intersect (Expr Expr) Expr)\n\n(rule (\n    (= x3 (intersect x1 x2))\n    (= f1 (f x1))\n    (= f2 (f x2))\n)(\n    (set (intersect f1 f2) (f x3))\n))\n\n(define a1 (Var \"a1\")) (define a2 (Var \"a2\")) (define a3 (Var \"a3\"))\n(define b1 (Var \"b1\")) (define b2 (Var \"b2\")) (define b3 (Var \"b3\"))\n\n;; e-graph 1: f(a) = f(b), f(f(a))\n(define t1 (f (f a1)))\n(define fb1 (f b1))\n(union (f a1) fb1)\n\n;; e-graph 2: f(f(a)) = f(f(b))\n(define t2  (f (f a2)))\n(define t2p (f (f b2)))\n(union t2 t2p)\n\n(set (intersect a1 a2) a3)\n(set (intersect b1 b2) b3)\n\n(run 100)\n\n(define t3 (f (f a3)))\n(extract :variants 5 t3)\n\n;; f(f(a)) = f(f(b)) is preserved\n(check (= (f (f a3)) (f (f b3))))\n;; but not f(a) = f(b), it was only in e-graph 1\n(check (!= (f a3) (f b3)))",
  "interval": "(datatype Math\n  (Num Rational)\n  (Var String)\n  (Mul Math Math))\n\n(function hi (Math) Rational :merge (min old new))\n(function lo (Math) Rational :merge (max old new))\n\n(rule ((= mul (Mul a b)))\n      ((set (lo mul) \n          (min (min (* (lo a) (lo b)) (* (lo a) (hi b)))\n               (min (* (hi a) (lo b)) (* (hi a) (hi b)))))))\n\n(define x (Var \"x\"))\n(define e (Mul x x))\n\n(set (lo x) (rational -10 1))\n(set (hi x) (rational 10 1))\n\n(run 1)\n\n(check (= (lo e) (rational -100 1)))\n\n(rule ((= mul (Mul a a)))\n      ((set (lo mul) (* (lo a) (lo a)))))\n\n(run 1)\n(check (= (lo e) (rational 100 1)))\n\n;; testing extraction of rationals\n(extract (lo e))\n",
  "knapsack": "(datatype expr \n    (Num i64)\n    (Add expr expr)\n    (Max expr expr))\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rewrite (Max (Num a) (Num b)) (Num (max a b)))\n\n; List of (weight, value) pairs\n(datatype objects\n    (Cons i64 i64 objects))\n(declare Nil objects)\n\n; Given a capacity and a list of objects, finds the maximum value of a\n; collection of objects whose total weight does not exceed the capacity.\n(function Knap (i64 objects) expr)\n\n(rule ((= f (Knap capacity (Cons weight val rest))) (<= weight capacity))\n      ((set (Knap capacity (Cons weight val rest))\n            (Max\n                (Add (Num val) (Knap (- capacity weight) rest))\n                (Knap capacity rest)))))\n\n(rule ((= f (Knap capacity (Cons weight val rest))) (> weight capacity))\n      ((set (Knap capacity (Cons weight val rest))\n            (Knap capacity rest))))\n\n(rule ((= f (Knap capacity Nil)))\n      ((set (Knap capacity Nil) (Num 0))))\n\n(define test1 (Knap 13 (Cons 5 5 (Cons 3 3 (Cons 12 12 (Cons 5 5 Nil))))))\n\n(define test2 (Knap 5 (Cons 6 6 Nil)))\n\n(define test3 (Knap 5 (Cons 1 1 (Cons 1 1 (Cons 1 1 Nil)))))\n\n(define test4 (Knap 15 (Cons 12 40 (Cons 2 20 (Cons 1 20 (Cons 1 10 (Cons 4 100 Nil)))))))\n\n; turn a (Num n) into n\n(function Unwrap (expr) i64)\n(rule ((= x (Num n))) ((set (Unwrap (Num n)) n)))\n\n(run 100)\n\n(extract (Unwrap test1))\n(check (= test1 (Num 13)))\n\n(extract (Unwrap test2))\n(check (= test2 (Num 0)))\n\n(extract (Unwrap test3))\n(check (= test3 (Num 3)))\n\n(extract (Unwrap test4))\n(check (= test4 (Num 150)))\n",
  "lambda": ";; NOTE: This file contains several unsafe operations\n(datatype Value (Num i64))\n(declare True Value)\n(declare False Value)\n(datatype VarType)\n(datatype Term\n    (Val Value)\n    (Var VarType)\n    (Add Term Term)\n    (Eq Term Term)\n    (App Term Term)\n    (Lam VarType Term)\n    (Let VarType Term Term)\n    (Fix VarType Term)\n    (If Term Term Term))\n(function V (String) VarType) \n(function From (Term) VarType)\n\n; All free variables are free,\n; but some free variables are more free than others\n; Freer variables will only contain variables\n; that will affect the evaluation\n; of the corresponding term\n; e.g., x is free in x - x, but not freer in x - x\n(sort StringSet (Map VarType i64))\n(function freer (Term) StringSet :merge (set-intersect old new))\n(rule ((= e (Val v)))\n      ((set (freer e) (empty))))\n(rule ((= e (Var v)))\n      ((set (freer e) (insert (empty) v 1))))\n(rule ((= e (Add e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Eq e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (App e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union fv1 fv2))))\n(rule ((= e (Lam var body))\n       (= (freer body) fv))\n      ((set (freer e) (map-remove fv var))))\n(rule ((= e (Let var e1 e2))\n       (= (freer e1) fv1)\n       (= (freer e2) fv2))\n      ((set (freer e) (set-union (map-remove fv1 var) fv2))))\n(rule ((= e (Fix var body))\n       (= (freer body) fv))\n      ((set (freer e) (map-remove fv var))))\n(rule ((= e (If c e1 e2))\n       (= (freer c) fv1)\n       (= (freer e1) fv2)\n       (= (freer e2) fv3))\n      ((set (freer e) (set-union fv1 (set-union fv2 fv3)))))\n\n;; START evals-to\n(function evals-to (Term) Value)\n\n(rule ((= e (Val val)))\n      ((union (evals-to e) val)))\n(rule ((= e (Add a b))\n       (= (Num va) (evals-to a))\n       (= (Num vb) (evals-to b)))\n      ((union (evals-to e) (Num (+ va vb)))))\n(rule ((= e (Eq a b))\n       (= (evals-to b) (evals-to a)))\n      ((union (evals-to e) True)))\n(rule ((= e (Eq a b))\n       (= va (evals-to a))\n       (= vb (evals-to b))\n       (!= va vb)) ; TODO: if true and false are non-mergeable datatype, \n                   ; we should be able to do != over it\n      ((union (evals-to e) False)))\n(rule ((= v (evals-to e)))\n      ((union e (Val v))))\n;; END evals-to\n\n; if-true\n(rewrite (If (Val True) then else) then)\n; if-false\n(rewrite (If (Val False) then else) else)\n; if-elim\n(rule ((= term (If (Eq (Var x) e) then else)))\n      ((Let x e then)\n       (Let x e else)))\n(rewrite (If (Eq (Var x) e) then else) else\n    :when ((= (Let x e then) (Let x e else))))\n\n; add-comm\n(rewrite (Add a b) (Add b a))\n; add-assoc\n(rewrite (Add (Add a b) c) (Add a (Add b c)))\n; eq-comm\n(rewrite (Eq a b) (Eq b a))\n\n; fix\n(rewrite (Fix v e) (Let v (Fix v e) e))\n; beta\n(rewrite (App (Lam v body) e) (Let v e body))\n; let-app\n(rewrite (Let v e (App a b)) (App (Let v e a) (Let v e b)))\n; let-add\n(rewrite (Let v e (Add a b)) (Add (Let v e a) (Let v e b)))\n; let-eq\n(rewrite (Let v e (Eq a b)) (Eq (Let v e a) (Let v e b)))\n; let-const\n(rewrite (Let v e c) c :when ((= const (evals-to c))))\n; let-if\n(rewrite (Let v e (If cond then else)) \n         (If (Let v e cond) (Let v e then) (Let v e else)))\n; let-var-same\n(rewrite (Let v1 e (Var v1)) e)\n; let-var-diff\n(rewrite (Let v1 e (Var v2)) (Var v2) :when ((!= v1 v2)))\n; let-lam-same\n(rewrite (Let v1 e (Lam v1 body)) (Lam v1 body))\n; let-lam-diff\n(rewrite (Let v1 e (Lam v2 body)) (Lam v2 (Let v1 e body))\n      :when ((!= v1 v2)\n             (= fvs (freer e))\n             (not-contains fvs v2)))\n(rule ((= expr (Let v1 e (Lam v2 body)))\n       (!= v1 v2)\n       (= fvs (freer e))\n       (contains fvs v2))\n      ((union expr (Lam (From expr) (Let v1 e (Let v2 (Var (From expr)) body))))))\n\n(relation result ())\n\n;; lambda_under\n(push)\n(define e \n        (Lam (V \"x\") \n             (Add (Val (Num 4))\n                  (App (Lam (V \"y\") (Var (V \"y\"))) (Val (Num 4))))))\n(run 10)\n(check (= e (Lam (V \"x\") (Val (Num 8)))))\n(pop)\n\n;; lambda_if_elim\n(push)\n(define e2 (If (Eq (Var (V \"a\")) (Var (V \"b\")))\n              (Add (Var (V \"a\")) (Var (V \"a\")))\n              (Add (Var (V \"a\")) (Var (V \"b\")))))\n(run 10)\n(check (= e2 (Add (Var (V \"a\")) (Var (V \"b\")))))\n(pop)\n\n;; lambda_let_simple\n(push)\n(define e3 (Let (V \"x\") (Val (Num 0))\n          (Let (V \"y\") (Val (Num 1))\n          (Add (Var (V \"x\")) (Var (V \"y\"))))))\n(run 10)\n(check (= e3 (Val (Num 1))))\n(pop)\n\n;; lambda_capture\n(push)\n(define e4 (Let (V \"x\") (Val (Num 1)) \n          (Lam (V \"x\") (Var (V \"x\")))))\n(run 10)\n(fail (check (= e4 (Lam (V \"x\") (Val (Num 1))))))\n(pop)\n\n;; lambda_capture_free\n(push)\n(define e5  (Let (V \"y\") (Add (Var (V \"x\")) (Var (V \"x\"))) \n           (Lam (V \"x\") (Var (V \"y\")))))\n(run 10)\n(check (contains (freer (Lam (V \"x\") (Var (V \"y\")))) (V \"y\")))\n(fail (check (= e5 (Lam (V \"x\") (Add (Var (V \"x\")) (Var (V \"x\")))))))\n(pop)\n\n;; lambda_closure_not_seven\n(push)\n(define e6\n     (Let (V \"five\") (Val (Num 5))\n     (Let (V \"add-five\") (Lam (V \"x\") (Add (Var (V \"x\")) (Var (V \"five\"))))\n     (Let (V \"five\") (Val (Num 6))\n     (App (Var (V \"add-five\")) (Val (Num 1)))))))\n(run 10)\n(fail (check (= e6 (Val (Num 7)))))\n(check (= e6 (Val (Num 6))))\n(pop)\n\n\n;; lambda_compose\n(push)\n(define e7\n    (Let (V \"compose\") (Lam (V \"f\") \n                       (Lam (V \"g\") \n                       (Lam (V \"x\") (App (Var (V \"f\"))\n                                         (App (Var (V \"g\")) \n                                              (Var (V \"x\")))))))\n    (Let (V \"add1\") (Lam (V \"y\") (Add (Var (V \"y\")) (Val (Num 1))))\n    (App (App (Var (V \"compose\")) (Var (V \"add1\"))) (Var (V \"add1\"))))))\n(run 20)\n\n(rule (\n    (= goal1 (Lam x (Add (Val (Num 1))\n                         (App (Lam y (Add (Val (Num 1)) (Var y)))\n                              (Var x)))))\n    (= goal2 (Lam x (Add (Var x) (Val (Num 2)))))\n)(\n    (result)\n))\n(run 1)\n(check (result))\n(pop)\n\n;; lambda_if_simple\n(push)\n(define e10 (If (Eq (Val (Num 1)) (Val (Num 1))) (Val (Num 7)) (Val (Num 9))))\n(run 4)\n(check (= e10 (Val (Num 7))))\n(pop)\n\n;; lambda_compose_many\n(push)\n(define e11\n    (Let (V \"compose\") (Lam (V \"f\") (Lam (V \"g\") (Lam (V \"x\") (App (Var (V \"f\"))\n                                                              (App (Var (V \"g\")) (Var (V \"x\")))))))\n    (Let (V \"add1\") (Lam (V \"y\") (Add (Var (V \"y\")) (Val (Num 1))))\n    (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n         (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n              (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                   (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                        (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                             (App (App (Var (V \"compose\")) (Var (V \"add1\")))\n                                  (Var (V \"add1\")))))))))))\n\n(run 30)\n(rule (\n    (= e11 (Lam x (Add (Var x) (Val (Num 7)))))\n)(\n    (result)\n))\n(run 1)\n(check (result))\n(pop)\n\n;; lambda_if\n(push)\n(define e8\n    (Let (V \"zeroone\") (Lam (V \"x\")\n         (If (Eq (Var (V \"x\")) (Val (Num 0)))\n             (Val (Num 0))\n             (Val (Num 1))))\n         (Add (App (Var (V \"zeroone\")) (Val (Num 0)))\n              (App (Var (V \"zeroone\")) (Val (Num 10)))))\n)\n(run 20)\n(check (= e8 (Val (Num 1))))\n(pop)\n",
  "levenshtein-distance": "; Datatypes\n\n(datatype expr \n    (Num i64)\n    (Add expr expr)\n    (Min expr expr expr))\n(rewrite (Add (Num a) (Num b)) (Num (+ a b)))\n(rewrite (Min (Num a) (Num b) (Num c)) (Num (min (min a b) c)))\n\n; `String` supports limited operations, let's just use it as a char type\n(datatype str\n    (Cons String str))\n(declare Empty str)\n\n; Length function\n\n(function Length (str) expr)\n\n(rule ((= f (Length Empty)))\n      ((set (Length Empty) (Num 0))))\n\n(rule ((= f (Length (Cons c cs))))\n      ((set (Length (Cons c cs)) (Add (Num 1) (Length cs)))))\n\n; EditDist function\n\n(function EditDist (str str) expr)\n\n(rule ((= f (EditDist Empty s)))\n      ((set (EditDist Empty s) (Length s))))\n\n(rule ((= f (EditDist s Empty)))\n      ((set (EditDist s Empty) (Length s))))\n\n(rule ((= f (EditDist (Cons head rest1) (Cons head rest2))))\n      ((set (EditDist (Cons head rest1) (Cons head rest2))\n            (EditDist rest1 rest2))))\n\n(rule ((= f (EditDist (Cons head1 rest1) (Cons head2 rest2))) (!= head1 head2))\n      ((set (EditDist (Cons head1 rest1) (Cons head2 rest2))\n            (Add (Num 1)\n                 (Min (EditDist rest1 rest2)\n                      (EditDist (Cons head1 rest1) rest2)\n                      (EditDist rest1 (Cons head2 rest2)))))))\n\n; Unwrap function - turn a (Num n) into n\n\n(function Unwrap (expr) i64)\n(rule ((= x (Num n))) ((set (Unwrap (Num n)) n)))\n\n; Tests\n(define HorseStr (Cons \"h\" (Cons \"o\" (Cons \"r\" (Cons \"s\" (Cons \"e\" Empty))))))\n(define RosStr (Cons \"r\" (Cons \"o\" (Cons \"s\" Empty))))\n(define IntentionStr (Cons \"i\" (Cons \"n\" (Cons \"t\" (Cons \"e\" (Cons \"n\" (Cons \"t\" (Cons \"i\" (Cons \"o\" (Cons \"n\" Empty))))))))))\n(define ExecutionStr (Cons \"e\" (Cons \"x\" (Cons \"e\" (Cons \"c\" (Cons \"u\" (Cons \"t\" (Cons \"i\" (Cons \"o\" (Cons \"n\" Empty))))))))))\n\n(define Test1 (EditDist HorseStr RosStr))\n(define Test2 (EditDist IntentionStr ExecutionStr))\n(define Test3 (EditDist HorseStr Empty))\n\n(run 100)\n\n(extract (Unwrap Test1))\n(check (= Test1 (Num 3)))\n\n(extract (Unwrap Test2))\n(check (= Test2 (Num 5)))\n\n(extract (Unwrap Test3))\n(check (= Test3 (Num 5)))\n",
  "map": "(sort MyMap (Map i64 String))\n\n(define my_map1 (insert (empty) 1 \"one\"))\n(define my_map2 (insert my_map1 2 \"two\"))\n\n(check (= \"one\" (get my_map1 1)))\n(extract my_map2)",
  "math": "(datatype Math\n    (Diff Math Math)\n    (Integral Math Math)\n    \n    (Add Math Math)\n    (Sub Math Math)\n    (Mul Math Math)\n    (Div Math Math)\n    (Pow Math Math)\n    (Ln Math)\n    (Sqrt Math)\n    \n    (Sin Math)\n    (Cos Math)\n    \n    (Const Rational)\n    (Var String))\n\n(relation MathU (Math))\n(rule ((= e (Diff x y))) ((MathU e)))\n(rule ((= e (Integral x y))) ((MathU e)))\n(rule ((= e (Add x y))) ((MathU e)))\n(rule ((= e (Sub x y))) ((MathU e)))\n(rule ((= e (Mul x y))) ((MathU e)))\n(rule ((= e (Div x y))) ((MathU e)))\n(rule ((= e (Pow x y))) ((MathU e)))\n(rule ((= e (Ln x))) ((MathU e)))\n(rule ((= e (Sqrt x))) ((MathU e)))\n(rule ((= e (Sin x))) ((MathU e)))\n(rule ((= e (Cos x))) ((MathU e)))\n(rule ((= e (Const x))) ((MathU e)))\n(rule ((= e (Var x))) ((MathU e)))\n\n(relation evals-to (Math Rational))\n\n(rule ((= e (Const c))) ((evals-to e c)))\n(rule ((= e (Add a b)) (evals-to a va) (evals-to b vb))\n      ((evals-to e (+ va vb))))\n(rule ((= e (Sub a b)) (evals-to a va) (evals-to b vb))\n      ((evals-to e (- va vb))))\n(rule ((= e (Mul a b)) (evals-to a va) (evals-to b vb))\n      ((evals-to e (* va vb))))\n(rule ((= e (Div a b)) (evals-to a va) (evals-to b vb) (!= vb (rational 0 1)))\n      ((evals-to e (/ va vb))))\n(rule ((evals-to x vx)) ((union x (Const vx))))\n\n(relation is-const (Math))\n(rule ((evals-to a va)) ((is-const a)))\n\n(relation is-sym (Math))\n(rule ((= e (Var s))) ((is-sym e)))\n\n(relation is-not-zero (Math))\n(rule ((evals-to x vx)\n       (!= vx (rational 0 1)))\n      ((is-not-zero x)))\n\n(relation is-const-or-distinct-var-demand (Math Math))\n(relation is-const-or-distinct-var (Math Math))\n(rule ((is-const-or-distinct-var-demand v w)\n       (is-const v))\n      ((is-const-or-distinct-var v w)))\n(rule ((is-const-or-distinct-var-demand v w)\n       (= v (Var vv))\n       (= w (Var vw))\n       (!= vv vw))\n      ((is-const-or-distinct-var v w)))\n\n(rewrite (Add a b) (Add b a))\n(rewrite (Mul a b) (Mul b a))\n(rewrite (Add a (Add b c)) (Add (Add a b) c))\n(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))\n\n(rewrite (Sub a b) (Add a (Mul (Const (rational -1 1)) b)))\n(rewrite (Div a b) (Mul a (Pow b (Const (rational -1 1)))) :when ((is-not-zero b)))\n\n(rewrite (Add a (Const (rational 0 1))) a)\n(rewrite (Mul a (Const (rational 0 1))) (Const (rational 0 1)))\n(rewrite (Mul a (Const (rational 1 1))) a)\n\n;; NOTE: these two rules are different from math.rs, as math.rs does pruning\n(rule ((MathU a) (!= a (Const (rational 0 1)))) ((union a (Add a (Const (rational 0 1))))))\n(rule ((MathU a) (!= a (Const (rational 1 1)))) ((union a (Mul a (Const (rational 1 1))))))\n\n(rewrite (Sub a a) (Const (rational 0 1)))\n(rewrite (Div a a) (Const (rational 1 1)) :when ((is-not-zero a)))\n\n(rewrite (Mul a (Add b c)) (Add (Mul a b) (Mul a c)))\n(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))\n\n(rewrite (Mul (Pow a b) (Pow a c)) (Pow a (Add b c)))\n(rewrite (Pow x (Const (rational 0 1))) (Const (rational 1 1)) :when ((is-not-zero x)))\n(rewrite (Pow x (Const (rational 1 1))) x)\n(rewrite (Pow x (Const (rational 2 1))) (Mul x x))\n(rewrite (Pow x (Const (rational -1 1))) (Div (Const (rational 1 1)) x) :when ((is-not-zero x)))\n(rewrite (Mul x (Div (Const (rational 1 1)) x)) (Const (rational 1 1)) :when ((is-not-zero x)))\n\n(rewrite (Diff x x) (Const (rational 1 1)) :when ((is-sym x)))\n(rule ((= e (Diff x c))\n       (is-sym x))\n      ((is-const-or-distinct-var-demand c x)))\n(rewrite (Diff x c) (Const (rational 0 1)) :when ((is-sym x) (is-const-or-distinct-var c x)))\n\n(rewrite (Diff x (Add a b)) (Add (Diff x a) (Diff x b)))\n(rewrite (Diff x (Mul a b)) (Add (Mul a (Diff x b)) (Mul b (Diff x a))))\n\n(rewrite (Diff x (Sin x)) (Cos x))\n(rewrite (Diff x (Cos x)) (Mul (Const (rational -1 1)) (Sin x)))\n\n(rewrite (Diff x (Ln x)) (Div (Const (rational 1 1)) x) :when ((is-not-zero x)))\n\n(rewrite (Diff x (Pow f g))\n         (Mul (Pow f g) \n              (Add (Mul (Diff x f) (Div g f)) \n                   (Mul (Diff x g) (Ln f)))) \n         :when ((is-not-zero f) \n                (is-not-zero g)))\n\n(rewrite (Integral (Const (rational 1 1)) x) x)\n(rewrite (Integral (Pow x c) x)\n         (Div (Pow x (Add c (Const (rational 1 1)))) (Add c (Const (rational 1 1)))) \n         :when ((is-const c)))\n(rewrite (Integral (Cos x) x) (Sin x))\n(rewrite (Integral (Sin x) x) (Mul (Const (rational -1 1)) (Cos x)))\n(rewrite (Integral (Add f g) x) (Add (Integral f x) (Integral g x)))\n(rewrite (Integral (Sub f g) x) (Sub (Integral f x) (Integral g x)))\n(rewrite (Integral (Mul a b) x) \n         (Sub (Mul a (Integral b x)) \n              (Integral (Mul (Diff x a) (Integral b x)) x)))\n\n;; math_simplify_root\n(push)\n(define start-expr\n    (Div (Const (rational 1 1))\n         (Sub (Div (Add (Const (rational 1 1))\n                        (Sqrt (Var \"five\")))\n                   (Const (rational 2 1)))\n              (Div (Sub (Const (rational 1 1))\n                        (Sqrt (Var \"five\")))\n                   (Const (rational 2 1))))))\n(run 11)\n(define end-expr\n    (Div (Const (rational 1 1))\n         (Sqrt (Var \"five\"))))\n(check (= start-expr end-expr))\n\n(pop)\n\n;; math_simplify_const\n(push)\n(define start-expr2 (Add (Const (rational 1 1))\n                        (Sub (Var \"a\") \n                             (Mul (Sub (Const (rational 2 1)) \n                                       (Const (rational 1 1))) \n                                  (Var \"a\")))))\n\n(run 6)\n\n(define end-expr2 (Const (rational 1 1)))\n(check (= start-expr2 end-expr2))\n(pop)\n\n;; math_simplify_factor\n(push)\n(define start-expr3 (Mul (Add (Var \"x\") (Const (rational 3 1)))\n                        (Add (Var \"x\") (Const (rational 1 1)))))\n(run 8)\n(define end-expr3 (Add (Add (Mul (Var \"x\") (Var \"x\"))\n                           (Mul (Const (rational 4 1)) (Var \"x\")))\n                           (Const (rational 3 1))))\n(check (= start-expr3 end-expr3))\n(pop)\n\n(simplify 5 (Add (Const (rational 1 1))\n                        (Sub (Var \"a\") \n                             (Mul (Sub (Const (rational 2 1)) \n                                       (Const (rational 1 1))) \n                                  (Var \"a\")))))\n",
  "matrix": "\n(datatype Dim (Times Dim Dim) (NamedDim String) (Lit i64))\n\n(rewrite (Times a (Times b c)) (Times (Times a b) c))\n(rewrite (Times (Times a b) c) (Times a (Times b c)) )\n(rewrite (Times (Lit i) (Lit j)) (Lit (* i j)))\n(rewrite (Times a b) (Times b a))\n\n(datatype MExpr \n    (MMul MExpr MExpr) \n    (Kron MExpr MExpr) \n    (NamedMat String)\n    (Id Dim)\n    ; DSum\n    ; HStack\n    ; VStack\n    ; Transpose\n    ; Inverse\n    ; Zero Math Math\n    ; ScalarMul \n)\n\n; alternative encoding (type A) = (Matrix n m) may be more useful for \"large story example\"\n(function nrows (MExpr) Dim)\n(function ncols (MExpr) Dim)\n\n(rewrite (nrows (Kron A B)) (Times (nrows A) (nrows B)))\n(rewrite (ncols (Kron A B)) (Times (ncols A) (ncols B)))\n\n(rewrite (nrows (MMul A B)) (nrows A))\n(rewrite (ncols (MMul A B)) (ncols B))\n\n(rewrite (nrows (Id n)) n)\n(rewrite (ncols (Id n)) n)\n\n(rewrite (MMul (Id n) A) A)\n(rewrite (MMul A (Id n)) A)\n\n(rewrite (MMul A (MMul B C)) (MMul (MMul A B) C))\n(rewrite (MMul (MMul A B) C) (MMul A (MMul B C)))\n\n(rewrite (Kron A (Kron B C)) (Kron (Kron A B) C))\n(rewrite (Kron (Kron A B) C) (Kron A (Kron B C)))\n\n(rewrite (Kron (MMul A C) (MMul B D))  (MMul (Kron A B) (Kron C D)))\n\n\n(rewrite (MMul (Kron A B) (Kron C D)) \n    (Kron (MMul A C) (MMul B D))\n    :when  \n        ((= (ncols A) (nrows C))\n        (= (ncols B) (nrows D)))\n)\n\n; demand\n(rule ((= e (MMul A B)))\n((let demand1 (ncols A))\n(let demand2 (nrows A))\n(let demand3 (ncols B))\n(let demand4 (nrows B)))\n)\n\n(rule ((= e (Kron A B)))\n((let demand1 (ncols A))\n(let demand2 (nrows A))\n(let demand3 (ncols B))\n(let demand4 (nrows B)))\n)\n\n\n(define n (NamedDim \"n\"))\n(define m (NamedDim \"m\"))\n(define p (NamedDim \"p\"))\n\n(define A (NamedMat \"A\"))\n(define B (NamedMat \"B\"))\n(define C (NamedMat \"C\"))\n\n(set (nrows A) n)\n(set (ncols A) n)\n(set (nrows B) m)\n(set (ncols B) m)\n(set (nrows C) p)\n(set (ncols C) p)\n(define ex1 (MMul (Kron (Id n) B) (Kron A (Id m))))\n(define rows1 (nrows ex1))\n(define cols1 (ncols ex1))\n\n(run 20)\n\n(check (= (nrows B) m))\n(check (= (nrows (Kron (Id n) B)) (Times n m)))\n(define simple_ex1 (Kron A B))\n(check (= ex1 simple_ex1))\n\n(define ex2 (MMul (Kron (Id p) C) (Kron A (Id m))))\n(run 10)\n(fail (check (= ex2 (Kron A C))))\n",
  "merge-during-rebuild": "; This file tests that non-union merges can be triggered during rebuilds as well\n; as \"inline\" during a set action. See issue #42\n\n(datatype N (Node i64))\n(function distance (N N) i64 :merge (min old new))\n\n(define a (Node 0))\n(define b (Node 1))\n(define x (Node 2))\n(define y (Node 3))\n(set (distance x y) 1)\n(set (distance a b) 2)\n\n(union a x)\n(union b y)\n\n(run 1)\n(check (= (distance x y) 1)) ; fails, the distance has gone up!\n",
  "merge-saturates": "(function foo () i64 :merge (min old new))\n\n(set (foo) 0)\n\n; This should break at iteration 0 because the merge doesn't cause any updates\n(rule ((= f (foo))) ((set (foo) 1)))\n(run 100)\n\n\n; This should run for about 50 iterations, because even though the merge doesn't\n; change the value of baz, it has a side effect of expanding the domain of bar.\n\n(function baz (i64) i64 :default 0)\n\n(function bar () i64 :merge (min (baz new) 0))\n\n(set (bar) 1)\n(set (bar) 2)\n\n(rule ((= f (baz x)) (< x 50))\n      ((set (bar) (+ x 1))))\n\n(run 100)\n(check (= 0 (baz 50)))\n",
  "name-resolution": "(datatype Math\n  (Add Math Math)\n  (Num i64))\n  \n(define zero (Num 0))\n\n\n;; zero here refers to the function/constant zero, not a free variable\n(rewrite (Add zero x) x)\n\n(define a (Add (Num 0) (Num 3)))\n(define b (Add (Num 7) (Num 9)))\n(define c (Num 16))\n(union b c)\n\n;; crash if we merge two numbers\n(rule (\n (= (Num x) (Num y))\n (!= x y)\n)(\n (panic \"ahhh\")\n))\n      \n      \n(run 10)",
  "path-union": "(datatype Node\n (mk i64))\n\n(relation edge (Node Node))\n(relation path (Node Node))\n            \n(rule ((edge x y))\n      ((path x y)))\n\n(rule ((path x y) (edge y z))\n      ((path x z)))\n\n(edge (mk 1) (mk 2))\n(edge (mk 2) (mk 3))\n(edge (mk 5) (mk 6))\n\n(union (mk 3) (mk 5))\n\n(run 10)\n(check (edge (mk 3) (mk 6)))\n(check (path (mk 1) (mk 6)))",
  "path": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n(rule ((path x y) (edge y z))\n      ((path x z)))\n        \n(edge 1 2)\n(edge 2 3)\n(edge 3 4)\n(check (edge 1 2))\n(fail (check (path 1 2)))\n(run 3)\n\n(print path)\n(check (path 1 4))\n(fail (check (path 4 1)))\n",
  "pathproof": "; proofs of connectivity are paths\n(datatype Proof\n  (Trans i64 Proof)\n  (Edge i64 i64))\n\n; We enhance the path relation to carry a proof field\n(relation path (i64 i64 Proof))\n(relation edge (i64 i64))\n\n(edge 2 1)\n(edge 3 2)\n(edge 1 3)\n\n(rule ((edge x y))  \n      ((path x y (Edge x y))))\n(rule ((edge x y) (path y z p))  \n      ((path x z (Trans x p))))\n\n; We consider equal all paths tha connect same points.\n; Smallest Extraction will extract shortest path.\n(rule ((path x y p1) (path x y p2))  \n      ((union p1 p2)))\n\n(run 3)\n(check (path 3 1 (Trans 3 (Edge 2 1))))\n; Would prefer being able to check\n;(check (path 1 2 _))\n; or extract\n;(extract (path 1 4 ?p))\n(print path)",
  "points-to": "; Identifiers represented as strings, keep some newtypes around to aid clarity\n(datatype ClassT (Class String))\n(datatype FieldT (Field String))\n\n(datatype Stmt\n    (New String ClassT)\n    ; Assign dst src\n    (Assign String String)\n    ; Store dst field src\n    (Store String FieldT String)\n    ; Load dst src field\n    (Load String String FieldT))\n\n(relation VarPointsTo (String ClassT))\n(relation HeapPointsTo (ClassT FieldT ClassT))\n\n; New variables point to classes they're initialized as\n(rule ((= x (New a b))) ((VarPointsTo a b)))\n\n; If I assign v1 <- v2 and v2 points to a class c2, then v1 points to class c2\n; as well\n(rule ((= x (Assign v1 v2)) (VarPointsTo v2 c2))\n      ((VarPointsTo v1 c2)))\n\n; If c1.f points to c2, and v2 points to class c1, then assigning v1 <- v2.f\n; means v1 points to c2\n(rule ((= x (Load v1 v2 f)) \n       (VarPointsTo v2 c1)\n       (HeapPointsTo c1 f c2))\n      ((VarPointsTo v1 c2)))\n\n; If v1 points to class c1, and v2 to c2, and if v1.f <- v2, then c1.f points to\n; c2\n(rule ((= x (Store v1 f v2))\n       (VarPointsTo v1 c1)\n       (VarPointsTo v2 c2))\n      ((HeapPointsTo c1 f c2)))\n\n; Example in \"From Datalog to Flix\"\n; l1: ClassA o1 = new ClassA();\n; l2: ClassB o2 = new ClassB();\n; l3: ClassB o3 = o2;\n; l4: o2.f = o1;\n; l5: Object r = o3.f;\n\n(define A (Class \"A\"))\n(define B (Class \"B\"))\n(define f (Field \"f\"))\n\n(define l1 (New \"o1\" A))\n(define l2 (New \"o2\" B))\n(define l3 (Assign \"o3\" \"o2\"))\n(define l4 (Store \"o2\" f \"o1\"))\n(define l5 (Load \"r\" \"o3\" f))\n\n(run 3)\n\n(check (VarPointsTo \"o1\" A))\n(check (VarPointsTo \"o2\" B))\n\n(check (VarPointsTo \"o3\" B))\n(check (HeapPointsTo B f A))\n(check (VarPointsTo \"r\" A))",
  "primitives": "(check (= (+ 2 2)  4))\n(check (= (- 2 1)  1))\n(check (= (- 1 2) -1))\n(check (< 1 2))\n(check (> 1 -2))",
  "prims": "; A nasty, imperative implementation of Prim's algorithm... in egglog!\n; https://en.wikipedia.org/wiki/Prim%27s_algorithm\n\n; Weighted edge (vertex 1 * vertex 2 * weight)\n(datatype edge (Edge i64 i64 i64))\n(relation edge-exists (edge))\n\n(relation true ())\n(true)\n(define infinity 99999999)  ; close enough\n\n; ==== PROBLEM INSTANCES ====\n\n; Graph 1\n; (1)--2--(2)\n;    \\     |\n;      1   2\n;        \\ |\n; (3)--3--(4)\n(ruleset graph1)\n(rule ((true))\n      ((edge-exists (Edge 1 2 2))\n       (edge-exists (Edge 1 4 1))\n       (edge-exists (Edge 2 4 2))\n       (edge-exists (Edge 3 4 3)))\n       :ruleset graph1)\n\n; Graph 2\n; (1)-2-(2)  (3)\n;  |\\   /|   / |\n;  | 3 5 |  4  |\n;  5  X  2 /   5\n;  | / \\ |/    |\n; (4)-4-(5)-7-(6)\n(ruleset graph2)\n(rule ((true))\n      ((edge-exists (Edge 1 2 1))\n       (edge-exists (Edge 1 4 5))\n       (edge-exists (Edge 1 5 3))\n       (edge-exists (Edge 2 4 5))\n       (edge-exists (Edge 2 5 2))\n       (edge-exists (Edge 3 5 4))\n       (edge-exists (Edge 3 6 5))\n       (edge-exists (Edge 4 5 4))\n       (edge-exists (Edge 5 6 7)))\n       :ruleset graph2)\n\n; ==== \"INIT\" RULESET ====\n\n(ruleset init)\n\n; Graph is undirected\n(rule ((= e (Edge x y weight)))\n      ((union e (Edge y x weight)))\n      :ruleset init)\n\n; Whether a vertex is included *so far* (this changes). Returns 0 or 1.\n(function vertex-included (i64) i64 :merge (max old new))\n\n; All vertices default to being not included (note vertex-included's :merge)\n(rule ((edge-exists (Edge x y weight)))\n      ((set (vertex-included x) 0))\n      :ruleset init)\n\n; Keep track of the current iteration\n(function current-iteration () i64 :merge (max old new))\n\n; Map iteration to best edge found so far\n(function iteration-to-best-edge (i64) edge :merge new)\n(function iteration-to-best-edge-weight (i64) i64 :merge new)\n\n(rule ((true))\n      ((set (vertex-included 1) 1)  ; Initially just include vertex 1\n       (set (current-iteration) 0)\n       (set (iteration-to-best-edge-weight 0) infinity))\n      :ruleset init)\n\n; === \"CHOOSE BEST EDGE\" RULESET ===\n\n(relation edge-in-mst (edge))  ; whether an edge is in our solution\n\n(ruleset choose-best-edge)\n(rule ((= i (current-iteration))\n       (edge-exists (Edge x y weight))\n       (= 1 (vertex-included x))\n       (= 0 (vertex-included y))\n       (< weight (iteration-to-best-edge-weight i)))\n      ((set (iteration-to-best-edge-weight i) weight)\n       (set (iteration-to-best-edge i) (Edge x y weight)))\n      :ruleset choose-best-edge)\n\n; === \"FINISH ITERATION\" RULESET ===\n\n(ruleset finish-iteration)\n(rule ((= i (current-iteration))\n       (= (Edge x y weight) (iteration-to-best-edge i)))\n      ((edge-in-mst (Edge x y weight))    ; incorporate chosen best edge\n       (set (vertex-included x) 1)        ; mark its vertices as included\n       (set (vertex-included y) 1)\n       (set (current-iteration) (+ i 1))  ; advance iteration\n       (set (iteration-to-best-edge-weight (+ i 1)) infinity))\n      :ruleset finish-iteration)\n\n; === RUN VIA SCHEDULE ===\n\n(run-schedule\n    (saturate init graph1)  ; change to graph2 to see other example\n    (saturate (saturate choose-best-edge) finish-iteration)\n)\n\n; === PRINT RESULTS ===\n\n; (print edge-in-mst) ; this is not very helpful\n\n; Just copy canonical edges to solution\n(relation solution (i64 i64 i64))\n\n(ruleset finalize)\n(rule ((edge-in-mst (Edge x y weight)) (< x y))\n      ((solution x y weight))\n      :ruleset finalize)\n(run-schedule (saturate finalize))\n\n(print solution) ; this is better\n",
  "proofs": "(datatype Math\n    (Add Math Math)\n    (Sub Math Math)\n    (Const Rational)\n    (Var String))\n\n(datatype AstMath\n  (AstAdd AstMath AstMath)\n  (AstSub AstMath AstMath)\n  (AstConst Rational)\n  (AstVar String))\n\n(datatype ProofList)\n\n;; There are two types of proofs:\n;; 1) Provenance proofs justify the existance of a term \n;; 2) Equality proofs prove two terms are equal \n;; Equality proofs `a = b` also double as\n;; provenance proofs `a` and `b`\n;; When a proof `a = b` is used as a provenance proof, it is a proof of `b`\n(datatype Proof\n  ;; proves that a term exists in the database\n  (Original AstMath)\n  ;; proves two terms were set equal in the database\n  (OriginalEq AstMath AstMath)\n  ;; justifies the fact that a rule fired\n  ;; the proof list justifies each of the premises in order\n  ;; it then justifies all of the equality constraints in order\n  (Rule ProofList String)\n  ;; using a rule justification,\n  ;; proves a term exists\n  (RuleTerm Proof AstMath)\n  ;; using a rule justification, proves two terms are equal\n  (RuleEquality Proof AstMath AstMath)\n\n  ;; given proofs for x1 = x2, x2 = x3, ..., xn = xn+1\n  ;; proves that x1 = xn+1 and x1 and xn+1 exist\n  (Transitivity ProofList)\n  ;; given x1 = x2, proves x2 = x1\n  (Flip Proof)\n  ;; given a proof for a term t1, proves that t1 is equal\n  ;; to another term t2 via equality proofs on their children\n  (Congruence Proof ProofList)\n  ;; a placeholder for a proof of equality between two\n  ;; terms which can be proven equal using the graph\n  ;; stored in the `Eq` relation\n  (DemandEq AstMath AstMath :cost 10000000))\n\n;; ProofList definitions\n(function Cons (Proof ProofList) ProofList)\n(declare Null ProofList)\n\n;; prove two terms equal\n(function EqGraph (AstMath AstMath) Proof  :cost 100000 :merge old)\n\n(datatype TrmPrf\n  (MakeTrmPrf AstMath Proof))\n\n;; get child terms, proofs, and child terms\n(function TrmOf (TrmPrf) AstMath :cost 10000)\n(function PrfOf (TrmPrf) Proof :cost 100000)\n(function Child1 (AstMath) AstMath :cost 100000)\n(function Child2 (AstMath) AstMath :cost 100000)\n\n\n;; For every Add in the database,\n;; store an AstAdd representative\n;; and a proof of that representative\n(function AddRep (Math Math) TrmPrf\n  :on_merge (\n  (let t1 (TrmOf old))\n  (let t2 (TrmOf new))\n  (let p1 (PrfOf old))\n  (let x1 (Child1 t1))\n  (let y1 (Child2 t1))\n  (let x2 (Child1 t2))\n  (let y2 (Child2 t2))\n  (let cong-prf\n    (Congruence p1\n      (Cons (DemandEq x1 x2)\n        (Cons (DemandEq y1 y2)\n          Null))))\n  (set (EqGraph t1 t2) cong-prf)\n  (set (EqGraph t2 t1) (Flip cong-prf))\n)\n  :merge old)\n\n(function SubRep (Math Math) TrmPrf\n  :on_merge (\n  (let t1 (TrmOf old))\n  (let t2 (TrmOf new))\n  (let p1 (PrfOf old))\n  (let x1 (Child1 t1))\n  (let y1 (Child2 t1))\n  (let x2 (Child1 t2))\n  (let y2 (Child2 t2))\n  (let cong-prf\n    (Congruence p1\n      (Cons (DemandEq x1 x2)\n        (Cons (DemandEq y1 y2)\n          Null))))\n  (set (EqGraph t1 t2) cong-prf)\n  (set (EqGraph t2 t1) (Flip cong-prf))\n) :merge old)\n(function ConstRep (Rational) TrmPrf :merge old)\n(function VarRep (String) TrmPrf :merge old)\n\n\n;; ############################## NORMAL RULES\n\n(rule ((= t (Add a b))\n       (= tp (AddRep a b))\n       (= term (TrmOf tp))\n       (= proof (PrfOf tp)))\n      ((union (Add a b) (Add (Add a b) (Const (rational 0 1))))\n       (let rhs (AstAdd term (AstConst (rational 0 1))))\n       (let ruleprf (Rule (Cons proof\n                            Null)\n                          \"add-identity\"))\n       (let trmprf (MakeTrmPrf rhs (RuleTerm ruleprf rhs)))\n       (set (AddRep (Add a b) (Const (rational 0 1)))\n            trmprf)\n       (set (TrmOf trmprf) rhs)\n       (set (PrfOf trmprf) (RuleTerm ruleprf rhs))\n        \n       (set (EqGraph term rhs)\n           (RuleEquality ruleprf term rhs))\n       (set (EqGraph rhs term)\n           (Flip (RuleEquality ruleprf term rhs)))))\n\n(rule ((= t (Add a b)) ;; (rewrite (Add a b) (Add b c))\n       (= tp (AddRep a b))\n       (= lhs (TrmOf tp))\n       (= proof (PrfOf tp))\n       (= c1 (Child1 lhs))\n       (= c2 (Child2 lhs)))\n      ((union (Add a b) (Add b a)) ;; normal rhs\n       (let ruleprf (Rule (Cons proof\n                                Null)\n                          \"add-commute\"))\n       (let rhs (AstAdd c2 c1))\n       (let trmprf (MakeTrmPrf rhs (RuleTerm ruleprf rhs)))\n       (set (AddRep b a)\n            trmprf)\n       (set (TrmOf trmprf) rhs)\n       (set (PrfOf trmprf) (RuleTerm ruleprf rhs))\n\n       (set (EqGraph lhs rhs) ;; equality edge ->\n           (RuleEquality ruleprf lhs rhs))\n       (set (EqGraph rhs lhs) ;; equality edge ->\n           (Flip (RuleEquality ruleprf lhs rhs)))))\n\n; (rewrite (Add a (Add b c)) (Add (Add a b) c))\n(rule ((= t (Add a (Add b c)))\n       (= tp (AddRep a (Add b c)))\n       (= term (TrmOf tp))\n       (= proof (PrfOf tp))\n       (= c1 (Child1 term))\n       (= c2 (Child2 term))\n       (= tp2 (AddRep b c))\n       (= c2term (TrmOf tp2))\n       (= proof-right (PrfOf tp2))\n       (= c2termc1 (Child1 c2term))\n       (= c2termc2 (Child2 c2term)))\n      ((union (Add a (Add b c)) (Add (Add a b) c))\n       (let newrep (AstAdd c1 c2term))\n       (let newrepproof\n         (Congruence\n             proof\n             (Cons \n                (DemandEq c1 c1)\n                (Cons\n                  (DemandEq c2 c2term)\n                    Null))))\n       (let ruleproof\n         (Rule \n          (Cons\n            newrepproof\n            Null)\n          \"add-assoc\"))\n       ;; first, add our new representative to the graph via congruence\n       (set (EqGraph term newrep) newrepproof)\n       (set (EqGraph newrep term) newrepproof)\n       (let rhs (AstAdd (AstAdd c1 c2termc1)\n                       c2termc2))\n       (let trmprf\n            (MakeTrmPrf rhs (RuleTerm ruleproof rhs)))\n       ;; Add a proof for our RHS\n       (set (AddRep (Add a b) c)\n            trmprf)\n       (set (TrmOf trmprf) rhs)\n       (set (PrfOf trmprf) (RuleTerm ruleproof rhs))\n\n       ;; prove equality between new representative and the RHS \n       (set (EqGraph newrep rhs)\n               (RuleEquality ruleproof\n                  newrep rhs))\n       (set (EqGraph newrep rhs)\n               (Flip (RuleEquality ruleproof\n                  newrep rhs)))))\n\n\n;; ########################## PROOF RULES\n\n(ruleset proof-rules)\n;; children\n(rule ((= a (AstAdd c1 c2)))\n      ((set (Child1 a) c1)\n       (set (Child2 a) c2))\n      :ruleset proof-rules)\n(rule ((= a (AstSub c1 c2)))\n      ((set (Child1 a) c1)\n       (set (Child2 a) c2))\n      :ruleset proof-rules)\n\n(rule ((= trmprf (MakeTrmPrf t p)))\n      ((set (TrmOf trmprf) t)\n       (set (PrfOf trmprf) p))\n      :ruleset proof-rules)\n\n\n(ruleset proof-extract)\n\n;; Silly function to get the proof\n(function GetProof (AstMath) Proof :cost 1000000000)\n(rule ((= tp (AddRep a b))\n       (= term (TrmOf tp))\n       (= proof (PrfOf tp)))\n      ((set (GetProof term) proof))\n      :ruleset proof-extract)\n(rule ((= tp (SubRep a b))\n       (= term (TrmOf tp))\n       (= proof (PrfOf tp)))\n      ((set (GetProof term) proof))\n      :ruleset proof-extract)\n(rule ((= tp (ConstRep a))\n       (= term (TrmOf tp))\n       (= proof (PrfOf tp)))\n      ((set (GetProof term) proof))\n      :ruleset proof-extract)\n(rule ((= tp (VarRep a))\n       (= term (TrmOf tp))\n       (= proof (PrfOf tp)))\n      ((set (GetProof term) proof))\n      :ruleset proof-extract)\n\n;; start term, end term, current progress term, proof\n(function ProofBetween (AstMath AstMath AstMath) ProofList :cost 100000 :merge old)\n\n;; start proof search for equalities\n(rule ((= e (DemandEq t1 t2)))\n      ((set (ProofBetween t1 t2 t1) Null))\n      :ruleset proof-extract)\n;; do one step of proof search to find a path\n(rule ((= proof (ProofBetween t1 t2 tmid))\n       (= eproof (EqGraph tmid next)))\n      ((set (ProofBetween t1 t2 next)\n            (Cons eproof proof)))\n      :ruleset proof-extract)\n;; when you find a path, union it with the equality proof\n(rule ((= e (DemandEq t1 t2))\n       (= prooflist (ProofBetween t1 t2 t2)))\n      ((set (DemandEq t1 t2) (Transitivity prooflist)))\n      :ruleset proof-extract)\n\n\n\n(define two (rational 2 1))\n(define start1 (Add (Var \"x\") (Const two)))\n;; add original proofs\n(set (VarRep \"x\")\n     (MakeTrmPrf (AstVar \"x\") (Original (AstVar \"x\"))))\n(set (ConstRep two)\n     (MakeTrmPrf (AstConst two) (Original (AstConst two))))\n(define addx2 (AstAdd (AstVar \"x\") (AstConst two)))\n(define add2x (AstAdd (AstConst two) (AstVar \"x\")))\n(set (AddRep (Var \"x\") (Const two))\n     (MakeTrmPrf\n       addx2\n       (Original (AstAdd (AstVar \"x\") (AstConst two)))))\n\n(run proof-rules 1000)\n(run 1)\n(run proof-rules 1000)\n(run 1)\n(run proof-rules 1000)\n(run 1)\n(run proof-rules 1000)\n\n(define zero (AstConst (rational 0 1)))\n(define addzero (AstAdd addx2 zero))\n(define addzerofront (AstAdd (AstAdd zero (AstVar \"x\")) (AstConst two)))\n\n(DemandEq addx2 add2x)\n(DemandEq addx2 addzerofront)\n\n(run proof-extract 100)\n\n\n(check (!= (Var \"x\") (Const two)))\n(check (= (Add (Var \"x\") (Const two))\n          (Add (Const two) (Var \"x\"))))\n(check\n  (= (GetProof (AstAdd (AstVar \"x\") (AstConst two)))\n     (Original (AstAdd (AstVar \"x\") (AstConst two)))))\n\n(check\n  (= (GetProof add2x)\n     (RuleTerm\n       (Rule (Cons (Original addx2) Null)\"add-commute\")\n       add2x\n       )))\n\n(check (= (DemandEq addx2 add2x)\n          (Transitivity\n            (Cons\n              (RuleEquality\n                (Rule (Cons (Original addx2) Null)\"add-commute\")\n                addx2\n                add2x)\n              Null))))\n\n\n(check (= (DemandEq addx2 addzero)\n          (Transitivity\n            (Cons\n              (RuleEquality\n                (Rule\n                  (Cons\n                    (Original addx2) Null) \"add-identity\")\n                addx2\n                addzero)\n              Null))))\n\n(check (= (DemandEq addx2 addzerofront)\n          (Transitivity\n            (Cons\n              ;; 0+(x+2) -> (0+x)+2\n              (RuleEquality\n                ;; proof that the assoc rule fires\n                (Rule\n                  (Cons\n                   (Congruence \n                     ;; proof of 0+(x+2)\n                     (RuleTerm\n                      (Rule (Cons (RuleTerm (Rule (Cons (Original addx2) Null) \"add-identity\") addzero) Null) \"add-commute\")\n                     (AstAdd zero addx2))\n                    \n                     ;; children already equal\n                     (Cons (Transitivity Null) (Cons (Transitivity Null) Null)))\n                   Null) \"add-assoc\")\n                (AstAdd zero addx2) addzerofront)\n              \n              \n              ;; (x+2)+0 -> 0+(x+2)\n              (Cons\n                (RuleEquality\n                  (Rule (Cons (RuleTerm (Rule (Cons (Original addx2) Null) \"add-identity\") addzero) Null) \"add-commute\")\n                  \n                  addzero\n                  \n                  (AstAdd zero addx2))\n              \n              ;; x+2 -> (x+2)+0\n              (Cons (RuleEquality\n                      (Rule (Cons (Original addx2) Null) \"add-identity\")\n                      addx2\n                      addzero)\n              \n              Null)))\n          )))",
  "push-pop": "(function foo () i64 :merge (max old new))\n\n(set (foo) 1)\n(check (= (foo) 1))\n\n(push)\n(set (foo) 2)\n(check (= (foo) 2))\n(pop)\n\n(check (= (foo) 1))",
  "resolution": "; Resolution theorem proving\n; \n; Traditional resolution theorem provers maintain a clause database\n; of formulas in Conjunction Normal Form (CNF a big And of Ors).\n; Each clause is a set of positive and negative literals\n; The prover saturates this set by taking two clauses \n; {a}\\/c1  {not a}\\/c2 and creating a new clause c1 \\/ c2.\n; Clauses also are pruned by simplications, unit propagation,\n; and subsumption.\n; These systems use sophisticated term indexing to find matching clauses\n\n; A natural question is whether egglog's saturation and term indexing gives\n; a leg up towards building one of these systems. A programmable one even,\n; with built in support for equality reasoning\n\n; Resolution is provided by a join\n; unit propagation is an equation solving process and egraph substitution\n; Clause Simplification is provided by rewrite rules\n\n; This encoding seems about right but is unsatisfying\n; Using AC to encode the set nature of clauses is inefficient\n\n; An important aspect of these provers that seems challenging to encode shallowly\n; is that the match also occurs modulo _unification_.\n; The unification variables of each clause are not globally scoped, really\n; they are scoped outside the body of each clase in an implicit \\forall\n; This encoding as it stands really only supports ground atoms modulo equality\n\n(datatype Bool)\n(declare True Bool)\n(declare False Bool)\n(function or (Bool Bool) Bool)\n(function negate (Bool) Bool)\n\n; clauses are assumed in the normal form (or a (or b (or c False)))\n\n(set (negate False) True)\n(set (negate True) False)\n\n; \"Solving\" negation equations\n(rule ((= (negate p) True)) ((union p False)))\n(rule ((= (negate p) False)) ((union p True)))\n\n; canonicalize associtivity. \"append\" for clauses\n; terminate with false\n(rewrite (or (or a  b) c) (or a (or b c)))\n; commutativity\n(rewrite (or a (or b c)) (or b (or a c)))\n\n;absoprtion\n(rewrite (or a (or a b)) (or a b))\n(rewrite (or a (or (negate a) b)) True)\n\n; simplification\n(rewrite (or False a) a)\n(rewrite (or a False) a)\n(rewrite (or True a) True)\n(rewrite (or a True) True)\n\n; unit propagation\n; This is kind of interesting actually.\n; Looks a bit like equation solving\n\n; The following is not valid egglog but could be?\n;(rewrite p True    \n;    :when ((= True (or p False))))\n\n(rule ((= True (or p False))) ((union p True)))\n\n; resolution\n; This counts on commutativity to bubble everything possible up to the front of the clause.\n(rule ((= True (or a as)) (= True (or (negate a) bs)))\n      ((set (or as bs) True)))\n\n; example predicate\n(function p (i64) Bool)\n(define p0 (p 0))\n(define p1 (p 1))\n(define p2 (p 2))\n;(set (or p0 (or p1 (or p2 False))) True)\n;(set (or (negate p0) (or p1 (or (negate p2) False))) True)\n(set (or p1 (or (negate p2) False)) True)\n(set (or p2 (or (negate p0) False)) True)\n(set (or p0 (or (negate p1) False)) True)\n(union p1 False)\n(set (or (negate p0) (or p1 (or p2 False))) True)\n(run 10)\n(print or)\n(print p)\n(print True)\n(print False)\n(check (!= True False))\n(check (= p0 False))\n(check (= p2 False))\n\n; we could turn the original axioms into _patterns_  in all possible directions.\n; Which is kind of compelling\n; (rule ((or (pat x)))  )\n; or let a unification expansion happen and use thos\n\n\n",
  "rw-analysis": ";;;;;;;;;;;;;;;;\n;; Abstact Domain\n;;;;;;;;;;;;;;;;\n\n; Top means it can be an arbitrary value\n(datatype Val (I i64))\n(declare Top Val)\n(declare True Val)\n(declare False Val)\n(relation Bool (Val))\n(Bool True)\n(Bool False)\n\n(function merge-val (Val Val) Val)\n\n(rewrite (merge-val Top x) Top)\n(rewrite (merge-val x Top) Top)\n(rewrite (merge-val True  False) Top)\n(rewrite (merge-val True  (I x))   Top)\n(rewrite (merge-val False True)  Top)\n(rewrite (merge-val False (I x))   Top)\n(rewrite (merge-val (I x) (I y)) Top :when ((!= x y)))\n(rewrite (merge-val x x) x)\n\n(function add-val (Val Val) Val)\n\n(rewrite (add-val Top x) Top)\n(rewrite (add-val x Top) Top)\n(rewrite (add-val True x) Top)\n(rewrite (add-val False x) Top)\n(rewrite (add-val x True) Top)\n(rewrite (add-val x False) Top)\n(rewrite (add-val (I x) (I y)) (I (+ x y)))\n\n(function eq-val (Val Val) Val)\n\n(rewrite (eq-val Top x) Top)\n(rewrite (eq-val x Top) Top)\n(rewrite (eq-val True False) False)\n(rewrite (eq-val True (I x)) False)\n(rewrite (eq-val False True) False)\n(rewrite (eq-val False (I x)) False)\n(rewrite (eq-val (I x) True) False)\n(rewrite (eq-val (I x) False) False)\n(rewrite (eq-val x x) True)\n\n(datatype VarT (V String))\n(datatype Loc (L i64))\n(datatype Exp\n    (Add VarT VarT)\n    (Eq VarT VarT)\n    (Var VarT)\n    (Const Val))\n(datatype ProgStmt\n    (Ass VarT Exp)\n    (If VarT Loc Loc)\n    (Goto Loc)\n    (Call VarT))\n(declare End ProgStmt)\n(function Prog (Loc) ProgStmt)\n(relation RProg (Loc ProgStmt))\n\n(function const-prop (Loc VarT) Val :merge (merge-val old new))\n\n;;;;;;;;;;;;;;;;\n;; ASS Case\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n\n; propagate x = k\n(rule (\n    (RProg (L li) (Ass x (Const k)))\n)(\n    (set (const-prop (L (+ li 1)) x) k)\n))\n\n; propagate x = a + b (non-constant)\n(rule (\n    (RProg l (Ass x (Add x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n    (= l (L li))\n)(\n    (set (const-prop (L (+ li 1)) x) (add-val v1 v2))\n))\n\n; propagate x = a == b\n(rule (\n    (RProg l (Ass x (Eq x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n    (= l (L li))\n)(\n    (set (const-prop (L (+ li 1)) x) (eq-val v1 v2))\n))\n\n; propagate other vars\n(rule (\n    (RProg (L li) (Ass (V x) e))\n    (= val (const-prop (L li) (V y)))\n    (!= x y)\n)(\n    (set (const-prop (L (+ li 1)) (V y)) val)\n))\n\n;; TRANSFORMATION \n\n; generate demand for biop\n(rule (\n    (= (Prog l) (Ass x (Add x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n)(\n    (add-val v1 v2)\n))\n\n(rule (\n    (= (Prog l) (Ass x (Eq x1 x2)))\n    (= v1 (const-prop l x1))\n    (= v2 (const-prop l x2))\n)(\n    (eq-val v1 v2)\n))\n\n; replace x = a + b (constant)\n(rule (\n    (= (Prog l) (Ass x (Add x1 x2)))\n    (= (I val) (add-val (const-prop l x1)\n                        (const-prop l x2)))\n)(\n    (RProg l (Ass x (Const (I val))))\n))\n\n; replace x = a + b (non-contant)\n(rule (\n    (= (Prog l) (Ass x (Add x1 x2)))\n    (= Top (add-val (const-prop l x1)\n                      (const-prop l x2)))\n)(\n    (RProg l (Ass x (Add x1 x2)))\n))\n\n; replace x = a == b (constant)\n(rule (\n    (= (Prog l) (Ass x (Eq x1 x2)))\n    (= b (eq-val (const-prop l x1) (const-prop l x2)))\n    (Bool b)\n)(\n    (RProg l (Ass x (Const b)))\n))\n\n; replace x = a == b (non-constant)\n(rule (\n    (= (Prog l) (Ass x (Eq x1 x2)))\n    (= Top (eq-val (const-prop l x1) (const-prop l x2)))\n)(\n    (RProg l (Ass x (Eq x1 x2)))\n))\n\n; replace x = k\n(rule (\n    (= (Prog l) (Ass x (Const val)))\n)(\n    (RProg l (Ass x (Const val)))\n))\n\n;;;;;;;;;;;;;;;;\n;; CALL CASE\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n(rule (\n    (RProg l (Call f))\n    (= val (const-prop l x))\n    (= l (L li))\n)(\n    (set (const-prop (L (+ li 1)) x) val)\n))\n\n;; TRANSFORMATION\n(rule (\n    (= (Prog l) (Call f))\n)(\n    (RProg l (Call f))\n))\n\n;;;;;;;;;;;;;;;;\n;; IF CASE\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n(rule (\n    (RProg l (If b l1 l2))\n    (= val (const-prop l x))\n)(\n    (set (const-prop l1 x) val)\n    (set (const-prop l2 x) val)\n))\n\n;; TRANSFORMATION\n\n; replace if true\n(rule (\n    (= (Prog l) (If b l1 l2))\n    (= True (const-prop l b))\n)(\n    (RProg l (Goto l1))\n))\n\n; replace if false\n(rule (\n    (= (Prog l) (If b l1 l2))\n    (= False (const-prop l b))\n)(\n    (RProg l (Goto l2))\n))\n\n; replace if Top\n(rule (\n    (= (Prog l) (If b l1 l2))\n    (= Top (const-prop l b))\n)(\n    (RProg l (If b l1 l2))\n))\n\n;;;;;;;;;;;;;;;;\n;; GOTO CASE\n;;;;;;;;;;;;;;;;\n\n;; PROPAGATION\n(rule (\n    (RProg l1 (Goto l2))\n    (= val (const-prop l1 x))\n)(\n    (set (const-prop l2 x) val)\n))\n\n;; TRANSFORMATION\n(rule (\n    (= (Prog l1) (Goto l2))\n)(\n    (RProg l1 (Goto l2))\n))\n\n;;;;;;;;;;;;;;;;\n;; TEST\n;;;;;;;;;;;;;;;;\n\n(union (Prog (L 0)) (Ass (V \"b\") (Const Top)))\n(union (Prog (L 1)) (Ass (V \"ten\") (Const (I 10))))\n(union (Prog (L 2)) (Ass (V \"one\") (Const (I 1))))\n(union (Prog (L 3)) (Ass (V \"zero\") (Const (I 0))))\n; x := 10\n(union (Prog (L 4)) (Ass (V \"x\") (Const (I 10))))\n; while (...) {\n(union (Prog (L 5)) (If (V \"b\") (L 6) (L 13)))\n;     if (x == 10) {\n(union (Prog (L 6)) (Ass (V \"cond\") (Eq (V \"x\") (V \"ten\"))))\n(union (Prog (L 7)) (If (V \"cond\") (L 8) (L 10)))\n;         DoSomething();\n(union (Prog (L 8)) (Call (V \"DoSomething\")))\n;     }\n(union (Prog (L 9)) (Goto (L 12)))\n;     else {\n;         DoSomething();\n(union (Prog (L 10)) (Call (V \"DoSomethingElse\")))\n;         x := x + 1;\n(union (Prog (L 11)) (Ass (V \"x\") (Add (V \"x\") (V \"one\"))))\n;; (union (Prog (L 11)) (Call (V \"DoSomethingElse\")))\n;     }\n(union (Prog (L 12)) (Goto (L 5)))\n; y := x\n(union (Prog (L 13)) (Ass (V \"y\") (Add (V \"x\") (V \"zero\"))))\n(union (Prog (L 14)) End)\n\n(run 20)\n\n(check (= (const-prop (L 14) (V \"y\")) (I 10)))\n\n",
  "schedule-demo": "; Step with alternating feet, left before right\n(relation left (i64))\n(relation right (i64))\n\n(left 0)\n(right 0)\n\n(ruleset step-left)\n(rule ((left x) (right x))\n      ((left (+ x 1)))\n      :ruleset step-left)\n\n(ruleset step-right)\n(rule ((left x) (right y) (= x (+ y 1)))\n      ((right x))\n      :ruleset step-right)\n\n(run-schedule\n      (repeat 10\n            (saturate step-right)\n            (saturate step-left)))\n\n; We took 10 steps with the left, but the right couldn't go the first round,\n; so we took only 9 steps with the right.\n(check (left 10))\n(check (right 9))\n(fail (check (left 11)))\n(fail (check (right 10)))\n",
  "stratified": "(relation path (i64 i64))\n(relation edge (i64 i64))\n\n(rule ((edge x y))\n      ((path x y)))\n\n(edge 1 2)\n(edge 2 3)\n(edge 3 4)\n(check (edge 1 2))\n(run 3)\n(check (path 1 2))\n\n(ruleset path-rules)\n\n(rule ((path x y) (edge y z))\n      ((path x z))\n      :ruleset path-rules)\n\n(edge 3 8)\n(run path-rules 1)\n(check (path 1 3))\n\n\n\n; Should fail\n; (check (path 1 4))\n; (check (path 3 8)) \n",
  "string_quotes": "(function f () String)\n(input f \"tests/string_quotes.csv\")\n(check (= (f) \"abc\"))\n",
  "typecheck": "; type checking for simply typed lambda calculus\n\n(datatype Type \n  (TArr Type Type) ; t1 -> t2\n)\n(declare TUnit Type)\n\n(datatype Expr \n  (Lam String Type Expr) ; lam x : t . e\n  (App Expr Expr) \n  (Var String) \n)\n(declare MyUnit Expr)\n\n(datatype Ctx \n  (Cons String Type Ctx)\n)\n(declare Nil Ctx)\n\n; ctx |- expr : type\n(function typeof (Ctx Expr) Type)\n\n; ctx |- () : unit\n(rewrite (typeof ctx MyUnit) TUnit)\n\n; ctx; x: t |- x : t\n(rewrite (typeof (Cons x t ctx) (Var x)) t)\n\n; ctx |- f :- t1 -> t2\n; ctx |- e : t1\n; -----------------\n; ctx |- f e : t2\n\n(rule (\n  (= (typeof ctx (App f e)) t2)\n)(\n  (typeof ctx f)\n  (typeof ctx e)\n))\n\n(rule (\n  (= (typeof ctx (App f e)) t1)\n  (= (typeof ctx f) (TArr (typeof ctx e) t2))\n)(\n  (union t1 t2)\n))\n\n; ctx |- x : t\n; ------------------ y != x \n; ctx; y: t |- x : t\n\n(rewrite (typeof (Cons y ty ctx) (Var x))\n         (typeof ctx (Var x))\n    :when ((!= x y)))\n\n; ctx; x: t1 |- e : t2\n; ------------------------------\n; ctx |- lam x: t1. e : t1 -> t2\n\n; rhs of rewrite creates demand\n(rewrite (typeof ctx (Lam x t1 e))\n         (TArr t1 (typeof (Cons x t1 ctx) e)))\n\n; TEST\n; ----\n\n; lam x : unit, f : unit -> unit . f x\n(define e \n  (Lam \"x\" TUnit \n       (Lam \"f\" (TArr TUnit TUnit)\n            (App (Var \"f\") (Var \"x\")))))\n\n; lam x : unit . x\n(define id (Lam \"x\" TUnit (Var \"x\")))\n(define t-id (typeof Nil id))\n\n; (e () id) = ()\n(define app-unit-id (App (App e MyUnit) id))\n(define t-app (typeof Nil app-unit-id))\n\n(define free (Lam \"x\" TUnit (Var \"y\")))\n(define t-free-ill (typeof Nil free))\n(define t-free-1 (typeof (Cons \"y\" TUnit Nil) free))\n(define t-free-2 (typeof (Cons \"y\" (TArr (TArr TUnit TUnit) TUnit) Nil) free))\n\n(run 15)\n\n(extract t-id)\n(check (= t-id (TArr TUnit TUnit)))\n\n(extract t-app)\n(check (= t-app TUnit))\n\n(extract t-free-1)\n(check (= t-free-1 (TArr TUnit TUnit)))\n(extract t-free-2)\n(check (= t-free-2 (TArr TUnit (TArr (TArr TUnit TUnit) TUnit))))\n; this will err\n; (extract t-free-ill)\n",
  "typeinfer": ";;;;;;;;;;;;;;;;;;;;;;\n;; Exprs and Types\n;;;;;;;;;;;;;;;;;;;;;;\n\n(datatype Ident)\n(datatype Expr)\n(datatype Type)\n(datatype Scheme)\n(datatype Ctx)\n;; TODO: can't do unit right now\n;; (sort QuantifiedVs (Map String MyUnit))\n(sort QuantifiedVs (Map Ident i64))\n\n(function Fresh (Ident i64) Ident)\n(function V (String) Ident)\n\n(function Var (Ident) Expr)\n(function App (Expr Expr) Expr)\n(function Abs (Ident Expr) Expr)\n(function Let (Ident Expr Expr) Expr)\n(function Num (i64) Expr)\n(function True () Expr)\n(function False () Expr)\n(function MyUnit () Expr)\n\n(function TVar (Ident) Type :cost 3)\n(function TArr (Type Type) Type :cost 1)\n(function TInt () Type :cost 1)\n(function TBool () Type :cost 1)\n(function TUnit () Type :cost 1)\n\n(function Forall (QuantifiedVs Type) Scheme)\n(function Nil () Ctx)\n(function Cons (Ident Scheme Ctx) Ctx)\n\n(relation ftvCtx (Ctx QuantifiedVs))\n(relation ftv (Type QuantifiedVs))\n(relation ftvScheme (Scheme QuantifiedVs))\n(relation has-qs (Ctx Type QuantifiedVs))\n(relation has-qs-demand (Ctx Type))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Expression size\n;;;;;;;;;;;;;;;;;;;;;;\n(relation expr-size (Expr i64))\n(rule ((= e (Num n)))((expr-size e 1)))\n(rule ((= e (Var x)))((expr-size e 1)))\n;; asserted facts will be cleared so we define them as rules\n(rule ((= e (True))) ((expr-size e 1)))\n(rule ((= e (False))) ((expr-size e 1)))\n(rule ((= e (MyUnit))) ((expr-size e 1)))\n(rule ((= e (App e1 e2)) \n       (expr-size e1 s1) \n       (expr-size e2 s2))\n      ((expr-size e (+ (+ s1 s2) 1))))\n(rule ((= e (Let x e1 e2)) \n       (expr-size e1 s1) \n       (expr-size e2 s2))\n      ((expr-size e (+ (+ s1 s2) 1))))\n(rule ((= e (Abs x e1)) \n       (expr-size e1 s1))\n      ((expr-size e (+ s1 1))))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Scheme and Context\n;;;;;;;;;;;;;;;;;;;;;;\n\n(rule ((= e (TBool)))((ftv e (empty))))\n(rule ((= e (TUnit)))((ftv e (empty))))\n(rule ((= e (TInt)))((ftv e (empty))))\n(rule ((= e (TVar x)))((ftv e (insert (empty) x 1))))\n(rule ((= e (TArr fr to))\n       (ftv fr s1)\n       (ftv to s2))\n      ((ftv e (set-union s1 s2))))\n(rule ((= c (Nil))) ((ftvCtx c (empty))))\n(rule ((= e (Forall qs t))\n       (ftv t fvs))\n      ((ftvScheme e (set-diff fvs qs)))) \n(rule ((= c (Cons x s n))\n       (ftvCtx n fvs1)\n       (ftvScheme s fvs2))\n      ((ftvCtx c (set-union fvs1 fvs2))))\n\n\n;; TODO: rewrite lookup to use native sets\n(function lookup (Ctx Ident) Scheme :cost 1000)\n(rewrite (lookup (Cons x s tl) x) s)\n(rule (\n  (= t (lookup (Cons y s tl) x))\n  (!= x y)\n)(\n  (union t (lookup tl x))\n))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Generalization and Instantiation\n;;;;;;;;;;;;;;;;;;;;;;\n\n(function generalize (Ctx Type) Scheme :cost 1000)\n(function instantiate (Scheme i64) Type :cost 1000)\n\n(rule ((has-qs-demand ctx (TInt)))\n      ((has-qs ctx (TInt) (empty))))\n(rule ((has-qs-demand ctx (TBool)))\n      ((has-qs ctx (TBool) (empty))))\n(rule ((has-qs-demand ctx (TUnit)))\n      ((has-qs ctx (TUnit) (empty))))\n\n(rule ((has-qs-demand ctx (TArr fr to)))\n      ((has-qs-demand ctx fr)\n       (has-qs-demand ctx to)))\n(rule ((has-qs-demand ctx (TArr fr to))\n       (has-qs ctx fr qs1)\n       (has-qs ctx to qs2))\n      ((has-qs ctx (TArr fr to) (set-union qs1 qs2))))\n\n(rule ((has-qs-demand ctx (TVar x))\n       (ftvCtx ctx key-set)\n       (= unused (get key-set x)))\n      ((has-qs ctx (TVar x) (empty))))\n(rule ((has-qs-demand ctx (TVar x))\n       (ftvCtx ctx key-set)\n       (not-contains key-set x))\n      ((has-qs ctx (TVar x) (insert (empty) x 1))))\n\n(rule ((= sc (generalize ctx t)))\n      ((has-qs-demand ctx t)))\n(rewrite (generalize ctx t)\n         (Forall qs t)\n         :when ((has-qs ctx t qs)))\n\n(function subst-fresh (QuantifiedVs Type i64) Type :cost 1000)\n(rewrite (subst-fresh vs (TInt) c) (TInt))\n(rewrite (subst-fresh vs (TBool) c) (TBool))\n(rewrite (subst-fresh vs (TUnit) c) (TUnit))\n(rewrite (subst-fresh vs (TArr fr to) c) \n         (TArr (subst-fresh vs fr c) (subst-fresh vs to c)))\n(rule ((= otype (subst-fresh vs (TVar s) c))\n       (= unused (get vs s)))\n      ((union otype (TVar (Fresh s c)))))\n(rule ((= otype (subst-fresh vs (TVar s) c))\n       (not-contains vs s))\n      ((union otype (TVar s))))\n\n(rewrite (instantiate (Forall vs t) c)\n         (subst-fresh vs t c))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Injectivity\n;;;;;;;;;;;;;;;;;;;;;;\n\n(rule ((= (TArr fr1 to1) (TArr fr2 to2)))\n      ((union fr1 fr2) \n       (union to1 to2)))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Type inference\n;;;;;;;;;;;;;;;;;;;;;;\n\n; ctx |- expr : type\n(function typeof (Ctx Expr i64) Type :cost 1000)\n\n;; Basic types (TInt, TBool, TUnit)\n(rewrite (typeof ctx (Num x) c) (TInt))\n(rewrite (typeof ctx (True) c) (TBool))\n(rewrite (typeof ctx (False) c) (TBool))\n(rewrite (typeof ctx (MyUnit) c) (TUnit))\n\n; sc = lookup(ctx, x)\n; t = instantiate(sc)\n; ---------------\n; ctx |- x : t\n(rewrite (typeof ctx (Var x)  c)\n         (instantiate (lookup ctx x) c))\n\n(rewrite \n  (typeof ctx (Abs x e) c)\n  (TArr (TVar (Fresh x c)) \n        (typeof (Cons x (Forall (empty) (TVar (Fresh x c)))\n                      ctx)\n                e cc))\n    :when ((= cc (+ c 1))))\n\n(rule ((= to (typeof ctx (App e1 e2) c))\n       (= c1 (+ c 1))\n       (expr-size e1 sz)\n       (= c2 (+ c (+ sz 1))))\n      ((union (typeof ctx e1 c1) \n              (TArr (typeof ctx e2 c2) to))))\n\n(rewrite (typeof ctx (Let x e1 e2) c)\n         (typeof (Cons x (generalize ctx (typeof ctx e1 c1)) \n                       ctx)\n                 e2 c2)\n    :when ((= c1 (+ c 1))\n           (expr-size e1 sz)\n           (= c2 (+ c (+ sz 1)))))\n\n;;;;;;;;;;;;;;;;;;;;;;\n;; Occurs check\n;;;;;;;;;;;;;;;;;;;;;;\n(relation occurs-check (Ident Type))\n(function errors () Ident)\n(rule ((= (TVar x) (TArr fr to)))\n      ((occurs-check x fr)\n       (occurs-check x to)))\n(rule ((occurs-check x (TVar x)))\n      ;; ((set (errors) x)))\n      ((panic \"occurs check fail\")))\n(rule ((occurs-check x (TArr fr to)))\n      ((occurs-check x fr)\n       (occurs-check x to)))\n\n(relation base-types (Type))\n(base-types (TInt))\n(base-types (TBool))\n(base-types (TUnit))\n(rule ((base-types t)\n       (= t (TArr fr to)))\n      ((panic \"Unifying base types with functions\")) )\n(rule ((= (TInt) (TBool))) ((panic \"Unifying base types\")))\n(rule ((= (TInt) (TUnit))) ((panic \"Unifying base types\")))\n(rule ((= (TBool) (TUnit))) ((panic \"Unifying base types\")))\n;;;;;;;;;;;;;;;;;;;;;;\n;; TEST\n;;;;;;;;;;;;;;;;;;;;;;\n\n(push)\n(define id (Abs (V \"x\") (Var (V \"x\"))))\n(define t-id (typeof (Nil) id 0))\n(run 100)\n(check (= t-id (TArr (TVar (Fresh (V \"x\") 0)) (TVar (Fresh (V \"x\") 0)))))\n(pop)\n\n(push)\n(define let-poly (Let (V \"id\") (Abs (V \"x\") (Var (V \"x\")))\n                  (App (App (Var (V \"id\")) (Var (V \"id\")))\n                       (App (Var (V \"id\")) (True)))))\n(define t-let-poly (typeof (Nil) let-poly 0))\n(run 100)\n(check (= t-let-poly (TBool)))\n(pop)\n\n(push)\n(define id-id (App (Abs (V \"x\") (Var (V \"x\")))\n                   (Abs (V \"y\") (Var (V \"y\")))))\n(define t-id-id (typeof (Nil) id-id 0))\n(run 100)\n(check (= t-id-id (TArr (TVar (Fresh (V \"y\") 3)) (TVar (Fresh (V \"y\") 3)))))\n(pop)\n\n\n(push)\n(define let-true (Let (V \"x\") (True) (True)))\n(define t-let-true (typeof (Nil) let-true 0))\n(run 100)\n(check (= t-let-true (TBool)))\n(pop)\n\n(push)\n\n(define let-var-true (Let (V \"x\") (True) (Var (V \"x\"))))\n(define t-let-var-true (typeof (Nil) let-var-true 0))\n(run 100)\n(check (= t-let-var-true (TBool)))\n(pop)\n\n(push)\n\n(define abs-id (Abs (V \"x\") \n                    (Let (V \"y\") (Abs (V \"z\") (Var (V \"z\"))) (Var (V \"y\")))))\n(define t-abs-id (typeof (Nil) abs-id 0))\n(run 100)\n(define x (Fresh (V \"x\") 0))\n(define z (Fresh (Fresh (V \"z\") 2) 4))\n(check (= t-abs-id (TArr (TVar x) (TArr (TVar z) (TVar z)))))\n(pop)\n\n(push)\n\n(define let-env (Let (V \"x\") (True) \n                (Let (V \"f\") (Abs (V \"a\") (Var (V \"a\")))\n                (Let (V \"x\") (MyUnit)\n                (App (Var (V \"f\")) (Var (V \"x\")))\n                ))))\n(define t-let-env (typeof (Nil) let-env 0))\n(run 100)\n(check (= t-let-env (TUnit)))\n(pop)\n\n(push)\n(define let-env-2a (Let (V \"x\") (MyUnit)\n                   (Let (V \"f\") (Abs (V \"y\") (Var (V \"x\")))\n                   (Let (V \"x\") (True)\n                   (App (Var (V \"f\")) (Var (V \"x\")))))))\n(define t-let-env-2a (typeof (Nil) let-env-2a 0))\n(run 100)\n(check (= t-let-env-2a (TUnit)))\n(pop)\n\n(push)\n\n(define let-env-2b (App (Abs (V \"x\")\n                             (Let (V \"f\") (Abs (V \"y\") (Var (V \"x\")))\n                             (Let (V \"x\") (True)\n                             (App (Var (V \"f\")) (Var (V \"x\"))))))\n                        (MyUnit)))\n(define t-let-env-2b (typeof (Nil) let-env-2b 0))\n(run 100)\n(check (= t-let-env-2b (TUnit)))\n(pop)\n\n(push)\n\n;; ((lambda (x) ((lambda (f) ((lambda (x) (f x)) #t)) (lambda (y) x))) 5)\n(define let-env-hard (App (Abs (V \"x\") \n                               (App (Abs (V \"f\") \n                                         (App (Abs (V \"x\") (App (Var (V \"f\")) (Var (V \"x\")))) \n                                              (True)))\n                                    (Abs (V \"y\") (Var (V \"x\")))))\n                          (MyUnit)))\n(define t-let-env-hard (typeof (Nil) let-env-hard 0))\n(run 100)\n(check (= t-let-env-hard (TUnit)))\n(pop)\n\n(push)\n\n(define let-inst (Let (V \"id\") (Abs (V \"x\") (Var (V \"x\")))\n                 (Let (V \"iid\") (Abs (V \"y\") (Var (V \"id\")))\n                 (App (Var (V \"iid\")) \n                      (App (Var (V \"id\")) (True))))) \n      :cost 1000)\n(define t-let-inst (typeof (Nil) let-inst 0) :cost 1000)\n(run 100)\n(check (= t-let-inst  (TArr (TVar (Fresh (Fresh (Fresh (V \"x\") 1) 5) 7)) (TVar (Fresh (Fresh (Fresh (V \"x\") 1) 5) 7)))))\n(pop)\n\n",
  "unification-points-to": "(datatype FuncT (Func String))\n(datatype StmtT (Stmt String))\n(datatype ExprT (Expr String))\n(datatype FieldT (Field String))\n(datatype TypeT (Type String))\n(datatype AllocT (Alloc AllocT) (AllocVar ExprT))\n\n(relation func (FuncT ExprT TypeT TypeT))\n(relation func-stmt (FuncT StmtT))\n(relation assign (StmtT TypeT ExprT ExprT))\n(relation field-assign (StmtT ExprT FieldT ExprT))\n(relation store (StmtT ExprT ExprT))\n(relation expr (StmtT ExprT))\n(relation return (StmtT ExprT))\n(relation eq (ExprT ExprT ExprT))\n(relation call (ExprT FuncT ExprT))\n(relation add (ExprT ExprT ExprT))\n(relation field (ExprT ExprT FieldT))\n(relation struct-lit-field (ExprT FieldT ExprT))\n(relation addr (ExprT ExprT FieldT))\n(relation load (ExprT ExprT))\n(relation malloc (ExprT TypeT))\n\n;; typedef struct s {\n;;   int x;\n;;   int y;\n;; } s;\n\n;; int mul(struct s q) { ... }\n\n;; int fact(int i) {\n;;   int c = i == 0;\n;;   if (c) {\n;;     return 1;\n;;   } else {\n;;     int j = i + -1;\n;;     int r = fact(j);\n;;     int prod = mul((struct s){i, r});\n;;     return prod;\n;;   }\n;; }\n;; (func (Func \"fact\") (Expr \"i\") (Type \"int\") (Type \"int\"))\n;; (func-stmt (Func \"fact\") (Stmt \"int c = i == 0;\"))\n;; (func-stmt (Func \"fact\") (Stmt \"if ...\"))\n;; (func-stmt (Func \"fact\") (Stmt \"return 1\"))\n;; (func-stmt (Func \"fact\") (Stmt \"int j = i + -1\"))\n;; (func-stmt (Func \"fact\") (Stmt \"int r = fact(j)\"))\n;; (func-stmt (Func \"fact\") (Stmt \"int prod = mul({ x: i, y: r })\"))\n;; (func-stmt (Func \"fact\") (Stmt \"return prod\"))\n;; (assign (Stmt \"int c = i == 0\") (Type \"int\") (Expr \"c\") (Expr \"i == 0\"))\n;; (assign (Stmt \"int j = i + -1\") (Type \"int\") (Expr \"j\") (Expr \"i + -1\"))\n;; (assign (Stmt \"int r = fact(j)\") (Type \"int\") (Expr \"r\") (Expr \"fact(j)\"))\n;; (assign (Stmt \"int prod = mul({ x: i, y: r })\") (Type \"int\") (Expr \"prod\") (Expr \"mul({ x: i, y: r })\"))\n;; (eq (Expr \"i == 0\") (Expr \"i\") (Expr \"0\"))\n;; (add (Expr \"i + -1\") (Expr \"i\") (Expr \"-1\"))\n;; (call (Expr \"fact(j)\") (Func \"fact\") (Expr \"j\"))\n;; (call (Expr \"mul({ x: i, y: r })\") (Func \"mul\") (Expr \"{ x: i, y: r }\"))\n;; (return (Stmt \"return prod\") (Expr \"prod\"))\n\n;; typedef struct s {\n;;   int *x;\n;;   int *y;\n;; } s;\n\n;; void swap(struct s *r) {\n;;   int **xp = &(r->x);\n;;   int **yp = &(r->y);\n;;   int *a = *xp;\n;;   int *b = *yp;\n;;   *xp = a;\n;;   *yp = b;\n;; }\n\n;; int f(int i) {\n;;   struct s *sp = malloc(sizeof(struct s));\n;;   int *u = malloc(sizeof(int));\n;;   int *v = malloc(sizeof(int));\n;;   *u = i;\n;;   *v = i;\n;;   *sp = (struct s){u, v};\n;;   swap(sp);\n;;   int **zpp = &(sp->x);\n;;   int *zp = *zpp;\n;;   return *zp;\n;; }\n(func (Func \"swap\") (Expr \"r\") (Type \"void\") (Type \"{int *x; int *y;}*\"))\n;; statements\n(func-stmt (Func \"swap\") (Stmt \"int **xp = &(r->x)\"))\n(func-stmt (Func \"swap\") (Stmt \"int **yp = &(r->y)\"))\n(func-stmt (Func \"swap\") (Stmt \"int *z = *xp\"))\n(func-stmt (Func \"swap\") (Stmt \"int *w = *yp\"))\n(func-stmt (Func \"swap\") (Stmt \"*xp = a\"))\n(func-stmt (Func \"swap\") (Stmt \"*yp = b\"))\n(assign (Stmt \"int **xp = &(r->x)\") (Type \"int **\") (Expr \"xp\") (Expr \"&(r->x)\"))\n(assign (Stmt \"int **yp = &(r->x)\") (Type \"int **\") (Expr \"yp\") (Expr \"&(r->y)\"))\n(assign (Stmt \"int *a = *xp\") (Type \"int *\") (Expr \"a\") (Expr \"*xp\"))\n(assign (Stmt \"int *b = *yp\") (Type \"int *\") (Expr \"b\") (Expr \"*yp\"))\n(store (Stmt \"*xp = a\") (Expr \"xp\") (Expr \"a\"))\n(store (Stmt \"*yp = b\") (Expr \"yp\") (Expr \"b\"))\n;; expressions\n(addr (Expr \"&(r->x)\") (Expr \"r\") (Field \"x\"))\n(addr (Expr \"&(r->y)\") (Expr \"r\") (Field \"y\"))\n(load (Expr \"*xp\") (Expr \"xp\"))\n(load (Expr \"*yp\") (Expr \"yp\"))\n\n(func (Func \"f\") (Expr \"i\") (Type \"int\") (Type \"int\"))\n;; statements\n(func-stmt (Func \"f\") (Stmt \"struct s *sp = malloc(sizeof(struct s))\"))\n(func-stmt (Func \"f\") (Stmt \"int *u = malloc(sizeof(int))\"))\n(func-stmt (Func \"f\") (Stmt \"int *v = malloc(sizeof(int))\"))\n(func-stmt (Func \"f\") (Stmt \"*u = i\"))\n(func-stmt (Func \"f\") (Stmt \"*v = i\"))\n(func-stmt (Func \"f\") (Stmt \"*sp = (struct s){u, v}\"))\n(func-stmt (Func \"f\") (Stmt \"swap(sp)\"))\n(func-stmt (Func \"f\") (Stmt \"int **zpp = &(sp->x)\"))\n(func-stmt (Func \"f\") (Stmt \"int *zp = *zpp\"))\n(func-stmt (Func \"f\") (Stmt \"return *zp\"))\n(assign (Stmt \"struct s *sp = malloc(sizeof(struct s))\") (Type \"struct s*\") (Expr \"sp\") (Expr \"malloc(sizeof(struct s))\"))\n(assign (Stmt \"int *u = malloc(sizeof(int))\") (Type \"int *\") (Expr \"u\") (Expr \"malloc(sizeof(int))\"))\n(assign (Stmt \"int *v = malloc(sizeof(int))\") (Type \"int *\") (Expr \"v\") (Expr \"malloc(sizeof(int))\"))\n(store (Stmt \"*u = i\") (Expr \"u\") (Expr \"i\"))\n(store (Stmt \"*v = i\") (Expr \"v\") (Expr \"i\"))\n(store (Stmt \"*sp = (struct s){u, v}\") (Expr \"sp\") (Expr \"(struct s){u, v}\"))\n(expr (Stmt \"swap(sp)\") (Expr \"swap(sp)\"))\n(assign (Stmt \"int **zpp = &(sp->x)\") (Type \"int **\") (Expr \"zpp\") (Expr \"&(sp->x)\"))\n(assign (Stmt \"int *zp = *zpp\") (Type \"int *\") (Expr \"zp\") (Expr \"*zpp\"))\n(return (Stmt \"return *zp\") (Expr \"*zp\"))\n;; expressions\n(malloc (Expr \"malloc(sizeof(struct s))\") (Type \"struct s\"))\n(malloc (Expr \"malloc(sizeof(int))\") (Type \"int\"))\n(struct-lit-field (Expr \"(struct s){u, v}\") (Field \"x\") (Expr \"u\"))\n(struct-lit-field (Expr \"(struct s){u, v}\") (Field \"y\") (Expr \"v\"))\n(call (Expr \"swap(sp)\") (Func \"swap\") (Expr \"sp\"))\n(addr (Expr \"&(sp->x)\") (Expr \"sp\") (Field \"x\"))\n(load (Expr \"*zpp\") (Expr \"zpp\"))\n(load (Expr \"*zp\") (Expr \"zp\"))\n\n;; a variable points to its allocation\n(function expr-points-to (ExprT) AllocT)\n(function ptr-points-to (AllocT) AllocT)\n\n;; If `v = malloc(...)`, then `v -> alloc[v]`.\n(rule (\n    (assign s t1 v c)\n    (malloc c t2)\n)(\n    (union (expr-points-to v) (AllocVar v))\n))\n\n;; If `t v = e` and `e -> a`, then `v -> a`.\n(rule (\n    (assign s t v e)\n    (= (expr-points-to e) a)\n)(\n    (union (expr-points-to v) a)\n))\n\n;; If `*v = u`, `v -> a`, and `u -> b`, then `a -> b`.\n(rule (\n    (store s v u)\n    (= (expr-points-to v) a)\n    (= (expr-points-to u) b)\n)(\n    (union (ptr-points-to a) b)\n))\n\n;; If `e.f -> a` then `e -> a`.\n(rule (\n    (field ef e f)\n    (= (expr-points-to ef) a)\n)(\n    (union (expr-points-to e) a)\n))\n\n;; If `e -> a` then `e.f -> a`.\n(rule (\n    (= (expr-points-to e) a)\n    (field ef e f)\n)(\n    (union (expr-points-to ef) a)    \n))\n\n;; If `u -> a` and `a -> b`, then `&(u->f) -> b`.\n(rule (\n    (= (expr-points-to u) a)\n    (= (ptr-points-to a) b)\n    (addr e u f)\n)(\n    (union (expr-points-to e) b)\n))\n\n;; If `u -> a` and `&(u->f) -> b`, then `a -> b`.\n(rule (\n    (= (expr-points-to u) a)\n    (addr e u f)\n    (= (expr-points-to e) b)\n)(\n    (union (ptr-points-to a) b)\n))\n\n;; If `(struct t){..., x, ...}` and `x -> b`, then `(struct t){..., x, ...} -> b`.\n(rule (\n    (struct-lit-field l f x)\n    (= (expr-points-to x) b)\n)(\n    (union (expr-points-to l) b)    \n))\n\n;; If `f(t* x)`, `f(v)`, and `v -> a`, then `x -> a`.\n(rule (\n    (func f x in out)\n    (call e f v)\n    (= (expr-points-to v) a)\n)(\n    (union (expr-points-to x) a)  \n))\n\n;; If `return u` in `f` and `u -> a`, then `f(z) -> a`.\n(rule (\n    (call e f v)\n    (func-stmt f s)\n    (return s u)\n    (= (expr-points-to u) a)\n)(\n    (union (expr-points-to e) a)    \n))\n\n;; store rule\n(rule (\n    (load e u)\n    (= (expr-points-to u) a)\n    (= (ptr-points-to a) b)\n)(\n    (union (expr-points-to e) b)\n))\n\n(run 40)\n\n(check (= (AllocVar (Expr \"v\")) (AllocVar (Expr \"u\"))))\n(check (!= (AllocVar (Expr \"v\")) (AllocVar (Expr \"sp\"))))\n\n(extract :variants 100 (AllocVar (Expr \"u\")))\n(extract :variants 100 (AllocVar (Expr \"sp\")))\n",
  "unify": "(datatype Expr\n  (Mul Expr Expr)\n  (Var String)\n  (Lit i64)\n)\n\n; Assume injectivity of Mul for unification\n(rule ((= (Mul a b) (Mul c d)))\n      ((union a c)\n       (union b d)))\n\n;; (relation False (i64))\n; If any Literal make equal to something it can't be, false is derived\n;(rule ((= (Lit i) (Lit j)) (!= i j))\n;      ((False 0)))\n(rule ((= (Lit i) (Mul a b)))\n      ((panic \"Literal cannot be equal to a product\")))\n\n(set (Mul (Var \"a\") (Var \"a\")) \n     (Mul (Lit 1) (Lit 2)))\n\n\n(run 3)\n(check (= (Var \"a\") (Lit 1)))\n(check (= (Lit 2) (Lit 1)))\n; (check (False 0)) ;; this should fail because we don't want prove false",
  "until": "; A simple group\n(datatype G)\n(declare I G)\n(declare A G)\n(declare B G)\n\n(function g* (G G) G)\n(function inv (G) G)\n(birewrite (g* (g* a b) c) (g* a (g* b c))) ; assoc\n(rewrite (g* I a) a) ; idl\n(rewrite (g* a I) a) ; idr\n\n; A is cyclic of period 4\n(rewrite (g* A (g* A (g* A A))) I)\n\n(define A2 (g* A A))\n(define A4 (g* A2 A2))\n(define A8 (g* A4 A4))\n\n; non terminating rule\n(relation allgs (G))\n(rule ((allgs x)) ((allgs (g* B x))))\n(allgs A)\n\n; if you remove :until, this will take a very long time\n(run 10000 :until (= A8 I))\n(check (= A8 I))\n(check (!= B A))\n(check (!= I A))\n; If you need multiple stop conditions, consider using a (relation relation stop (unit))\n; With rules filling it in with different stop conditions of interest.\n"
}